<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解析库Beautiful-Soup</title>
      <link href="/2022/05/17/class2/"/>
      <url>/2022/05/17/class2/</url>
      
        <content type="html"><![CDATA[<p>本文简单的记录一下自己对于Beautifulsoup库的理解</p><h2 id="Beautiful-Soup简介"><a href="#Beautiful-Soup简介" class="headerlink" title="Beautiful Soup简介"></a>Beautiful Soup简介</h2><p>Beautoful Soup借助网页的结构和属性来进行解析网页，比正则表达式要简便的多。省去很多繁琐的提取工作，大大提高了解析效率。</p><p>1：首先确保我们已经安装了Beautiful Soup 和 lxml. lxml的安装建议不要直接用pip install lxml，会遇到难以消除的错误，从官网直接下载.whl文件（注意和你的Python版本匹配）然后进行安装，亲测方便快捷。</p><h3 id="常用解析库"><a href="#常用解析库" class="headerlink" title="常用解析库"></a>常用解析库</h3><p>Beautiful Soup 支持四种解析库，我们推荐使用lxml（速度快，容错能力强，可以解析html 和 xml)。话不多说上代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如果还未安装的话，可以命令行输入$ pip install beautifulsoup4</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)  </span><br><span class="line"><span class="comment">#也可以不适用lxml 库使用默认的解析库</span></span><br><span class="line"><span class="comment">#soup = BeautifulSoup(html) 推荐使用lxml 解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试输出一下</span></span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure><pre><code>发现结果如下，我们的html代码被调整好了格式,不再是那么一坨</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse<span class="string">&#x27;s story</span></span><br><span class="line"><span class="string">  &lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;</span></span><br><span class="line"><span class="string">   &lt;b&gt;</span></span><br><span class="line"><span class="string">    The Dormouse&#x27;</span>s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p <span class="keyword">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span><br><span class="line">   Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">   &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/elsie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link1&quot;</span>&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/lacie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link2&quot;</span>&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   <span class="keyword">and</span></span><br><span class="line">   &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/tillie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link3&quot;</span>&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p <span class="keyword">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="prettify-方法"><a href="#prettify-方法" class="headerlink" title="prettify()方法"></a>prettify()方法</h3><p>这就是我们要介绍的第一个方法 prettify(). 这个方法将需要解析的字符串以标准的格式缩进格式输出，有一点需要注意一下，如果我们原来的字符串没有闭合的话(比如缺少</a>)经过这个调用会自动更正格式，补全代码（但这一步不是这个函数做的，而是进行初始化时就已经自动完成。）我们学习解析库肯定是要学如何提取信息的啊，那么怎么办呢：</p><h3 id="节点选择器-栗子"><a href="#节点选择器-栗子" class="headerlink" title="节点选择器-栗子"></a>节点选择器-栗子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html 同上面的</span><br><span class="line"><span class="built_in">print</span>(soup.title)</span><br><span class="line"><span class="built_in">print</span>(soup.title.string)</span><br><span class="line"><span class="built_in">print</span>(soup.p)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.title)) </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;title&gt;The Dormouse<span class="string">&#x27;s story&lt;/title&gt;</span></span><br><span class="line"><span class="string">The Dormouse&#x27;</span>s story</span><br><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;title&quot;</span> name=<span class="string">&quot;dromouse&quot;</span>&gt;&lt;b&gt;The Dormouse<span class="string">&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;</span>bs4.element.Tag<span class="string">&#x27;&gt;</span></span><br><span class="line"><span class="string">很直观的看到我们可以通过节点选择器简单的提取信息，选择器解析到的是Tag类型，其中的string属性可以得到节点的文本内容。那么只能提取到文本内容吗，显然不是。</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;列举一下信息提取方式</span></span><br><span class="line"><span class="string">print(soup.title.name)   #获取节点的名称</span></span><br><span class="line"><span class="string">print(soup.p.attrs)   #可以获取该节点的所有属性，比如id class name等等，它返回一些字典型数据，假如我们只想要其中一个属性那么可以这样</span></span><br><span class="line"><span class="string">print(soup.p.attrs[&#x27;</span>name<span class="string">&#x27;])  如果你觉得这样很烦，那么可以更直接一点</span></span><br><span class="line"><span class="string">print(soup.p[&#x27;</span>name<span class="string">&#x27;])  ****划重点了 提取出的属性值不一定唯一，name值一般只有一个所以输出为文本类型的，但同一标签里会有很多个class属性，因此class属性提取结果为列表型。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">每一步提取出来的节点都是&#x27;</span>bs4.element.Tag类型的，也就意味着我们可以二次提取，嵌套操作！</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(soup.head.title)</span><br><span class="line">&gt;&gt;&gt;&lt;title&gt;The Dormouse<span class="string">&#x27;s story&lt;/title&gt;</span></span><br><span class="line"><span class="string">这一步我们先提取出head 节点，然后再次调用节点选择器，提取出title.</span></span><br></pre></td></tr></table></figure><h3 id="关联选择。"><a href="#关联选择。" class="headerlink" title="关联选择。"></a>关联选择。</h3><p>网页结构并不是我们理想的那种，有时候我们需要多次选择，从一个基准出发然后选择他的子节点，父节点，兄弟节点（没有姐妹节点）。<br>1——选择节点元素后，如果想直接获得直接子节点我们调用contents属性即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）子节点</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">html = 原来的html 去除第一个p标签。</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.p.contents)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;Once upon a time there were three little sisters; and their names were\n&#x27;</span>, &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/elsie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, <span class="string">&#x27;,\n&#x27;</span>, &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/lacie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt;, <span class="string">&#x27; and\n&#x27;</span>, &lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/tillie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;, <span class="string">&#x27;;\nand they lived at the bottom of a well.&#x27;</span>]</span><br><span class="line"><span class="comment"># 可以看出返回结果为列表形式，这里列举的全是直接子节点，假如这些节点内部还有节点（孙节点），也不会单独列出来而是包含在对应的父节点里。</span></span><br><span class="line">不知你有没有想过为什么叫子节点，是不是有个children属性，答案是肯定的，真的有children属性，我们也可以通过调用它来提取子节点。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(soup.p.children)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> &lt;list_iterator <span class="built_in">object</span> at <span class="number">0x00000252F0878BE0</span>&gt; 这是一个迭代器，我们可以通过遍历提取出所有的内容。也可以通过<span class="built_in">list</span>将其转化为列表（但没必要这么做）</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> soup.p.children:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">&lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/elsie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;</span><br><span class="line">,</span><br><span class="line">&lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/lacie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt;</span><br><span class="line"> <span class="keyword">and</span></span><br><span class="line">&lt;a <span class="keyword">class</span>=<span class="string">&quot;sister&quot;</span> href=<span class="string">&quot;http://example.com/tillie&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;</span><br><span class="line">;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">（<span class="number">2</span>）父节点，祖先节点。</span><br><span class="line">如果你想把这个节点下的所有节点都列出来（子节点，子孙节点。。。。。）那么你可以调用descendants属性，同样这也是一个迭代器类.</span><br><span class="line">那么父节点相信你们也能猜一下喽，parents属性就可以调用，不在贴代码，自己实践一下吧。既然有子孙节点，那么祖先节点也一定存在（不要问为什么没有爷爷节点）对应的属性为parents.</span><br><span class="line">说完了先辈和后代，当然不能忘记同辈，我们还有兄弟节点需要了解一下。ps____这里不在赘述代码。</span><br><span class="line">（<span class="number">3</span>）兄弟节点</span><br><span class="line"><span class="built_in">print</span>(soup.p.next_sibling)</span><br><span class="line"><span class="built_in">print</span>(soup.p.prevoius_sibing)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(soup.p.prevoius_sibings))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(soup.p.next_siblings))</span><br><span class="line">分别可以得到你选择节点的下一个兄弟元素，上一个兄弟元素，以及前面所有兄弟元素的生成器，后面所有元素的生成器。</span><br><span class="line">（<span class="number">4</span>）提取信息</span><br><span class="line">前面已经讲了关联节点的选择方法，既然选择到了对应的节点那么如何获取对应的信息呢，我们的目的是提取信息的呀！</span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt; p class=&#x27;story&#x27;&gt;</span></span><br><span class="line"><span class="string">once upon a time</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://www.baidu.com&quot; class =&quot;sister&quot; id = &#x27;link1&#x27;&gt;Bob&lt;/a&gt;&lt;a href=&#x27;http://127.0.0.1:5000&#x27; class =&#x27;brother&#x27; id = &#x27;link2&#x27;&gt;Lacie&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.a.next_sibling))</span><br><span class="line"><span class="built_in">print</span>(soup.a.next_sibling)</span><br><span class="line"><span class="built_in">print</span>(soup.a.next_sibling.string)</span><br><span class="line"><span class="comment"># 选取的生成器元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(soup.a.next_siblings)[<span class="number">0</span>])  <span class="comment"># 获取特定节点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(soup.a.next_siblings)[<span class="number">0</span>].attr[<span class="string">&#x27;class&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(soup.a.next_siblings)[<span class="number">0</span>][<span class="string">&#x27;class&#x27;</span>]) <span class="comment">#获取节点的class属性</span></span><br><span class="line">和我们刚开始讲的方法是一样的！</span><br></pre></td></tr></table></figure><h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器."></a>方法选择器.</h3><p>上面的选择方法是通过属性选择，速度比较快，但明显不够灵活，还好BeautifulSoup 为我们提供了类似于正则表达式的一种查询方法find_all() find()等，输入对应的参数就可以灵活查询。<br>1：find_all() 和正则的findall()功能类似，但需要的不再是正则表达式，而是一些属性或者文本进行查询操作。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>故名思意通过节点的名称来查询</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">它的标准形式是find_all(name,attrs,recursive,text,**kwargs)</span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class = &#x27;A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;div class = &#x27;A_B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;h4&gt; hello &lt;/h4&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;body&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;ul class=&#x27;list&#x27; id = &#x27;list-1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&#x27;element&#x27;&gt;A&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&#x27;element&#x27;&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&#x27;element&#x27;&gt;C&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;ul class=&#x27;list list-small&#x27; id = &#x27;list-2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&#x27;element&#x27;&gt;A&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&#x27;element&#x27;&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(name = <span class="string">&#x27;ul&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.find_all(name=<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;ul <span class="keyword">class</span>=<span class="string">&quot;list&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;list-1&quot;</span>&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;C&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;, &lt;ul <span class="keyword">class</span>=<span class="string">&quot;list list-small&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;list-2&quot;</span>&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bs4.element.Tag&#x27;</span>&gt;</span><br><span class="line">通过返回结果我们可以清晰的看到返回的是列表形式，其中每一个均为bs4.element.Tag类型。</span><br><span class="line">既然是这种类型那么显然我们可以嵌套查询</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.find_all(name=<span class="string">&#x27;ul&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(ul.find_all(name=<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;C&lt;/li&gt;]</span><br><span class="line">[&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;]</span><br><span class="line">那么我们要获取每个li节点的信息也就顺理成章的可以写成</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.find_all(name=<span class="string">&#x27;ul&#x27;</span>):</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> ul.find_all(name = <span class="string">&#x27;li&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(li.string)</span><br></pre></td></tr></table></figure><h4 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">我们也可以输入属性查询例如：</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(attrs=&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;list-1&#x27;</span>&#125;))</span><br><span class="line">该参数为字典类型attrs=&#123;<span class="string">&#x27;**&#x27;</span>: <span class="string">&quot;***&quot;</span>&#125;</span><br><span class="line">对于一些常用的属性比如<span class="built_in">id</span> <span class="keyword">class</span> <span class="title class_">我们可以不用attrs传递</span>（可能是因为懒吧）我们可以这么做：</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="built_in">id</span> = <span class="string">&#x27;list-1&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(class_= <span class="string">&#x27;element&#x27;</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&lt;ul <span class="keyword">class</span>=<span class="string">&quot;list&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;list-1&quot;</span>&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;</span><br><span class="line">&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;C&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line"></span><br><span class="line">[&lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;C&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;A&lt;/li&gt;, &lt;li <span class="keyword">class</span>=<span class="string">&quot;element&quot;</span>&gt;B&lt;/li&gt;]</span><br><span class="line">可能有人要问为什么<span class="keyword">class</span>要加下划线，因为<span class="keyword">class</span>在Python里是关键字，我们这里需要区分一下。</span><br></pre></td></tr></table></figure><h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p>匹配节点的文本，传入的可以是字符串，或者正则表达式（有点抢饭碗的意思）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(text = re.<span class="built_in">compile</span>(<span class="string">&#x27;A&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(soup.find_all(text =<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line">返回所有匹配正则表达式的节点文本组成的列表。</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>返回单个元素，其他用法和find_all()相同还有一些方法，比如说</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_parents() /find_parent() <span class="comment">#返回祖先节点 /返回父节点</span></span><br><span class="line">find_next_siblings() / find_next_siblings <span class="comment">#返回后面所有兄弟节点/返回后面的第一个兄弟节点</span></span><br><span class="line">find_previous_siblings() / find_previous_sibling() <span class="comment">#返回前面所有兄弟节点/返回前面第一个兄弟节点</span></span><br><span class="line">find_all_next / find_next <span class="comment">#返回节点后所有符合条件的节点/ 返回第一个</span></span><br><span class="line">find_all_previous() / find_previous() <span class="comment">#返回节点前所有符合条件的节点/ 返回第一个</span></span><br></pre></td></tr></table></figure><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>如果对web熟悉的话那么CSS选择器你肯定很熟悉，不熟悉的话可以找一下教程。<br>使用CSS选择器我们需要调用select()方法，传入相应的CSS选择器即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.A .A_B&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;ul li&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;#list-1 .element&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持嵌套选择</span></span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">&#x27;ul&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(ul.select(<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性方法同上面所讲不在赘述</span></span><br><span class="line"><span class="comment"># 获取文本多加了一个方法get_text()</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> soup.select(<span class="string">&#x27;li&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(li.get_text())</span><br><span class="line"><span class="built_in">print</span>(li.string)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>o文明k，大概就这么多东西。推荐lxml库，节点选择器速度快但是很繁琐。建议使用find_all(),如果对CSS选择器熟悉的话，推荐select()方法选择。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣题解—1</title>
      <link href="/2021/09/09/%E5%8A%9B%E6%89%A3-%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2021/09/09/%E5%8A%9B%E6%89%A3-%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p> 本文记录自己悲催读研生涯中自学算法的过程及相应题解</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>所谓二分查找可以简单的理解为从有序数组首尾两端同时进行查找，从而大幅减少比较次数，进而提高查找效率。<br>以升序nums数组为例，查找目标target,对于特定下标i，我们只需进行如下比较：<br>1: nums[i] &#x3D; target，此时查找成功。<br>2: nums[i] &gt; target，则查找目标在i左侧。<br>3: nums[i] &lt; target，则查找目标在i右侧。<br>二分查找一般将i定为数组的中间下标，每次查找可以将查找范围缩小一半，查找的中止条件为left&gt;right及待查找数组的左下标大于右下标，此时下标越界查找终止，查找的时间复杂度为O(logn)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。</span><br><span class="line">如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line">请必须使用时间复杂度为 O(<span class="built_in">log</span> n) 的算法。</span><br></pre></td></tr></table></figure><p>根据题意我们可以轻而易举的想到二分查找算法，但题目中加入要求，需要我们返回目标值不存在于数组时的位置，以数组nums[1,3,5,7,9]为例，假定target为4,那么我们需要返回3作为索引pos。<br>nums[pos-1] &lt; target &lt;&#x3D; nums[pos]，因此题目的真实意思就是找到第一个大于等于target的下标，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left=0,right=nums.size()-1;</span><br><span class="line">        int ans = right+1;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            int mid = left + (right-left)/2;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>例: 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>以数组nums[1,2,3,4,5,6,7]，k&#x3D;3为例<br>向右旋转一步：[7,1,2,3,4,5,6]<br>向右旋转两步：[6,7,1,2,3,4,5]<br>向右旋转三步：[5,6,7,1,2,3,4]</p><p>解答：</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>开辟一个新的数组存放结果，本质上就是将nums[i]的值移动到nums[(i+k)modn]上，可以轻松的完成操作，但缺点就是空间代价高，当元素过多时显然不适合。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>我们的目标是将数组翻转，即将后k个数字翻转至最前面，因此可以将数组分为两部分，仍旧以上述数组为例。<br>原始数组              1，2，3，4，5，6，7<br>全部翻转              7，6，5，4，3，2，1<br>翻转[0,kmod(n-1)]     5，6，7，4，3，2，1<br>翻转[kmod(n-1), n-1]  5，6，7，1，2，3，4<br>根据示例我们可以很清楚的看到通过三次翻转就可以完成目标，且不需要多余的空间，是一种优秀的机制,代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        k = k % n;</span><br><span class="line">        int count = gcd(k, n);</span><br><span class="line">        for (int start = 0; start &lt; count; ++start) &#123;</span><br><span class="line">            int current = start;</span><br><span class="line">            int prev = nums[start];</span><br><span class="line">            do &#123;</span><br><span class="line">                int next = (current + k) % n;</span><br><span class="line">                swap(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; while (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水硕自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣 </tag>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DosBox</title>
      <link href="/2019/09/25/DosBox/"/>
      <url>/2019/09/25/DosBox/</url>
      
        <content type="html"><![CDATA[<h1 id="本文记录一下如何在windows10下编写8086汇编，"><a href="#本文记录一下如何在windows10下编写8086汇编，" class="headerlink" title="本文记录一下如何在windows10下编写8086汇编，"></a>本文记录一下如何在windows10下编写8086汇编，</h1><p>这是学校开设的一课程，虽然学校推荐使用masm系列，但是我们可以在微软官网找到masm8,不过需要vs2005支持貌似<br><img src="https://i.imgur.com/R5BZsB2.png"></p><h2 id="vs-大法好"><a href="#vs-大法好" class="headerlink" title="vs 大法好"></a>vs 大法好</h2><p>不过我搜了一下，万能的网友说vs大法好，天下第一。！<br>没错我信了他的邪然后开始折腾，过程倒是很简单，无非就是项目属性里开启自定义规则把masm那项勾上，同时函数入口点设置为main，这个具体就不说了，简单谈谈里面的坑吧。</p><ul><li>一般都是教你设置成功的代码可以愉快的执行，然后换成书上的代码（比如王爽的那本书）就会是无尽的报错。无法运行，我猜应该是vs对格式要求太过严格，导致一般的代码无法通过，具体原因没有深究毕竟我太菜了。</li><li>还有的说要选择windows桌面程序那个项目建立，直接选择空项目无法运行（我信你个鬼，糟老头子坏的很）</li></ul><p>这里放一个可以运行的代码<br><img src="https://i.imgur.com/dH08H2d.png"></p><p>没有任何输出仅仅是运行一下而已。</p><h2 id="DosBox-masm"><a href="#DosBox-masm" class="headerlink" title="DosBox + masm"></a>DosBox + masm</h2><p>折腾vs,折腾了好久看了很多的博客，结果大概就是心态崩了，去他喵的vs大法。github上一搜发现有个大佬提供了这个安装包，那就再折腾一下吧，DosBox + masm.<br>也就是用DosBox这个软件来模拟Dos环境从而完成我们的需求。<a href="https://github.com/FriendLey/assembly-language-learning" title="github链接">https://github.com/FriendLey/assembly-language-learning</a></p><p>安装DosBox很简单也不占空间，然后就是开始折腾了<br><img src="https://i.imgur.com/xgsEvxf.png"><br>界面很简单，两个随便关闭一个就一起结束了。初始它不会自动挂载目录，也就是一张白纸一样需要我们自己来建设。<br><img src="https://i.imgur.com/CQB8fg1.png"><br>我们需要找到这个文件拉到底部然后把我们的设置写进去（当然不限麻烦的可以每次运行都在命令行里重新设置一遍）。<br><img src="https://i.imgur.com/Z3wRL6t.png"><br>这样就可以把我们的文件压挂载，然后下次进入自动定位到这个文件夹，这时我们把第一次下载的那几个exe文件都放入统一的文件夹比如：masm<br>同时在那个小窗口里键入： path&#x3D;%path%;&#x2F;masm<br><img src="https://i.imgur.com/G4wzQW5.png"><br>这就是将这个文件夹加入到环境变量里。这样就可以愉快的写程序了。<br>例如hello world..万物始于hello world.<br><img src="https://i.imgur.com/LK7K1uR.png"></p><p>保存为.asm文件然后：<br><img src="https://i.imgur.com/6qsxStO.jpg"><br>键入上述命令，一路回车就可以发现你的文件夹里多了.obj文件和.exe文件（可是exe无法直接运行），然后我们直接键入test.exe就可以看到屏幕输出了Hello world!.完成了。<br><img src="https://i.imgur.com/B5Orhz1.png"></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>既然vs有点烦，那么我们该去linux下玩玩吧，linux倒是很平静，就是语法不能通过编译，一定是我太菜了还没入门，以后有时间再细细写这个。<br>还可以虚拟机下装xp，win7等等都很好操作。好好学习汇编，安全要用到的。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DosBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SalePrice_Predict</title>
      <link href="/2019/05/15/SalePrice-Predict/"/>
      <url>/2019/05/15/SalePrice-Predict/</url>
      
        <content type="html"><![CDATA[<p>   这是kaggle官网的一个基础入门题目，作为自己的一道入门尝试我觉得还是有一定意义的，将自己在kaggle学<br>习的简单技能做了简单的整合，毕竟只理论太容易被忘记。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="特征值的选取"><a href="#特征值的选取" class="headerlink" title="特征值的选取"></a>特征值的选取</h3><p>首先我们要知道我们的数据大概包含什么，然后才能进行下一步的特征值处理以及之后的预测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import xgboost as xgb</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">from scipy.stats import norm</span><br><span class="line">from scipy import stats</span><br><span class="line">import warnings</span><br><span class="line"></span><br><span class="line">train_path = &quot;train.csv&quot;</span><br><span class="line">train_data = pd.read_csv(train_path) #从csv文件中读取数据</span><br><span class="line">train_data.columns  #输出数据的列信息</span><br><span class="line">Index([&#x27;Id&#x27;, &#x27;MSSubClass&#x27;, &#x27;MSZoning&#x27;, &#x27;LotFrontage&#x27;, &#x27;LotArea&#x27;, &#x27;Street&#x27;,</span><br><span class="line">       &#x27;Alley&#x27;, &#x27;LotShape&#x27;, &#x27;LandContour&#x27;, &#x27;Utilities&#x27;, &#x27;LotConfig&#x27;,</span><br><span class="line">       &#x27;LandSlope&#x27;, &#x27;Neighborhood&#x27;, &#x27;Condition1&#x27;, &#x27;Condition2&#x27;, &#x27;BldgType&#x27;,</span><br><span class="line">       &#x27;HouseStyle&#x27;, &#x27;OverallQual&#x27;, &#x27;OverallCond&#x27;, &#x27;YearBuilt&#x27;, &#x27;YearRemodAdd&#x27;,</span><br><span class="line">       &#x27;RoofStyle&#x27;, &#x27;RoofMatl&#x27;, &#x27;Exterior1st&#x27;, &#x27;Exterior2nd&#x27;, &#x27;MasVnrType&#x27;,</span><br><span class="line">       &#x27;MasVnrArea&#x27;, &#x27;ExterQual&#x27;, &#x27;ExterCond&#x27;, &#x27;Foundation&#x27;, &#x27;BsmtQual&#x27;,</span><br><span class="line">       &#x27;BsmtCond&#x27;, &#x27;BsmtExposure&#x27;, &#x27;BsmtFinType1&#x27;, &#x27;BsmtFinSF1&#x27;,</span><br><span class="line">       &#x27;BsmtFinType2&#x27;, &#x27;BsmtFinSF2&#x27;, &#x27;BsmtUnfSF&#x27;, &#x27;TotalBsmtSF&#x27;, &#x27;Heating&#x27;,</span><br><span class="line">       &#x27;HeatingQC&#x27;, &#x27;CentralAir&#x27;, &#x27;Electrical&#x27;, &#x27;1stFlrSF&#x27;, &#x27;2ndFlrSF&#x27;,</span><br><span class="line">       &#x27;LowQualFinSF&#x27;, &#x27;GrLivArea&#x27;, &#x27;BsmtFullBath&#x27;, &#x27;BsmtHalfBath&#x27;, &#x27;FullBath&#x27;,</span><br><span class="line">       &#x27;HalfBath&#x27;, &#x27;BedroomAbvGr&#x27;, &#x27;KitchenAbvGr&#x27;, &#x27;KitchenQual&#x27;,</span><br><span class="line">       &#x27;TotRmsAbvGrd&#x27;, &#x27;Functional&#x27;, &#x27;Fireplaces&#x27;, &#x27;FireplaceQu&#x27;, &#x27;GarageType&#x27;,</span><br><span class="line">       &#x27;GarageYrBlt&#x27;, &#x27;GarageFinish&#x27;, &#x27;GarageCars&#x27;, &#x27;GarageArea&#x27;, &#x27;GarageQual&#x27;,</span><br><span class="line">       &#x27;GarageCond&#x27;, &#x27;PavedDrive&#x27;, &#x27;WoodDeckSF&#x27;, &#x27;OpenPorchSF&#x27;,</span><br><span class="line">       &#x27;EnclosedPorch&#x27;, &#x27;3SsnPorch&#x27;, &#x27;ScreenPorch&#x27;, &#x27;PoolArea&#x27;, &#x27;PoolQC&#x27;,</span><br><span class="line">       &#x27;Fence&#x27;, &#x27;MiscFeature&#x27;, &#x27;MiscVal&#x27;, &#x27;MoSold&#x27;, &#x27;YrSold&#x27;, &#x27;SaleType&#x27;,</span><br><span class="line">       &#x27;SaleCondition&#x27;, &#x27;SalePrice&#x27;],</span><br><span class="line">      dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure><p>这里我们看到列很多，可能一时无法下手，这时我们可以选择根据经验先选择一部分特征值（也可以通过绘制热点图来寻找一些最相关的变量）作为我们需要预测的特征值，或者直接对全部特征进行下一步的处理。<br><img src="https://i.imgur.com/7q29nIW.png"></p><p>通过pandas提供的corr()函数，我们可以计算列与列两两之间的相关性，颜色越浅关联度越高，我们可以把SalePrice列单独抽出来，方便观察。</p><p><img src="https://i.imgur.com/dRm0rrj.png"></p><p>我们可以直接选这十个特征值（记得除去SalePrice自己，不然会存在数据泄露，导致训练结果高的吓人，但对于真正的数据会一无是处。</p><p>这里我并没有这么做，因为舍弃了太多特征值，表现效果不理想。</p><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>选定特征值之后要做什么呢，当然是处理一些不太听话的数据（可能各种各样的情况导致的缺失，结合实际分析）<br>缺失值有两种处理方法<br>1：填充缺失值<br>2：删除缺失值所在的列<br>（删除有任意一行数据缺失的列，通过Xgboost大概是百分之80左右的正确率）</p><p>这里我们计算缺失率，将缺失过多的进行删除，我们有理由认为，他缺失过多是因为他不重要。缺失较少的根据我们的分析进行对应的填充操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#训练集的缺失值</span><br><span class="line">total = train_data.isnull().sum().sort_values(ascending=False)</span><br><span class="line">percent = (train_data.isnull().sum()/train_data.isnull().count()).sort_values(ascending=False)</span><br><span class="line">miss_data = pd.concat([total,percent],axis=1,keys=[&#x27;Total&#x27;,&#x27;Percent&#x27;])</span><br><span class="line">#miss_data[miss_data[&#x27;Total&#x27;]&gt;0]</span><br><span class="line">##对缺失值进行处理，Percent过大的直接剔除，不具备统计意义</span><br><span class="line">#测试值的缺失值</span><br><span class="line">total_test = test_data.isnull().sum().sort_values(ascending=False)</span><br><span class="line">percent_test = (test_data.isnull().sum()/test_data.isnull().count()).sort_values(ascending=False)</span><br><span class="line">miss_data_test = pd.concat([total_test,percent_test],axis=1,keys=[&quot;Total&quot;,&quot;Percent&quot;])</span><br><span class="line">#miss_data_test[miss_data_test[&#x27;Total&#x27;]&gt;0]</span><br></pre></td></tr></table></figure><p>这里我们将缺失值做了统计，然后计算出每一列的缺失率，按由高到低的顺序排列。</p><p><img src="https://i.imgur.com/6knppK7.png"></p><p>这里是训练集的缺失统计，我们可以看到前四个标签缺失过多，到了百分之八十多，最高可达百分之九十九，显然这个已经对我们的预测帮助不大，我们可以选择直接舍弃这几列。对于其他列进行对应的填充。</p><p>代码如下：举个例子GarageType为空的可能代表房子没有这个，因此我们对应填充None，其他的类似我们取一些出现频率最高的代替空值即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#训练集</span><br><span class="line">train_data[&#x27;Electrical&#x27;] = train_data[&#x27;Electrical&#x27;].fillna(&#x27;SBrkr&#x27;)</span><br><span class="line">train_data[&#x27;MasVnrType&#x27;] = train_data[&#x27;MasVnrType&#x27;].fillna(&#x27;SBrkr&#x27;)</span><br><span class="line">train_data[&#x27;LotFrontage&#x27;] = train_data.groupby(&#x27;Neighborhood&#x27;)[&#x27;LotFrontage&#x27;].transform(lambda x:x.fillna(x.median()))</span><br><span class="line">for i in [&#x27;GarageCond&#x27;,&#x27;GarageType&#x27;,&#x27;GarageFinish&#x27;,&#x27;GarageQual&#x27;]:  #车库缺失值填充</span><br><span class="line">    train_data[i] = train_data[i].fillna(&quot;None&quot;)</span><br><span class="line">for i in [&#x27;BsmtExposure&#x27;,&#x27;BsmtFinType2&#x27;,&#x27;BsmtFinType1&#x27;,&#x27;BsmtCond&#x27;,&#x27;BsmtQual&#x27;]:  #地下室缺失值填充</span><br><span class="line">    train_data[i] = train_data[i].fillna(&quot;None&quot;)</span><br><span class="line">train_data[&#x27;GarageYrBlt&#x27;] = train_data[&#x27;GarageYrBlt&#x27;].fillna(0)</span><br><span class="line">train_data[&#x27;MasVnrArea&#x27;] = train_data[&#x27;MasVnrArea&#x27;].fillna(0)</span><br><span class="line">#train_data = train_data.drop(cols_miss,axis=1)</span><br><span class="line">#当作空值处理，即无车库和地下室</span><br><span class="line">#测试数据</span><br><span class="line">test_data[&#x27;Functional&#x27;] = test_data[&#x27;Functional&#x27;].fillna(&#x27;Typ&#x27;)</span><br><span class="line">test_data[&#x27;KitchenQual&#x27;] = test_data[&#x27;KitchenQual&#x27;].fillna(&#x27;TA&#x27;)</span><br><span class="line">#test_data.drop(cols_miss,axis=1,inplace=True)</span><br><span class="line">for i in [&#x27;GarageCond&#x27;,&#x27;GarageType&#x27;,&#x27;GarageFinish&#x27;,&#x27;GarageQual&#x27;]:  #车库缺失值填充</span><br><span class="line">    test_data[i] = train_data[i].fillna(&quot;None&quot;)</span><br><span class="line">for i in [&#x27;BsmtExposure&#x27;,&#x27;BsmtFinType2&#x27;,&#x27;BsmtFinType1&#x27;,&#x27;BsmtCond&#x27;,&#x27;BsmtQual&#x27;]:  #地下室缺失值填充</span><br><span class="line">    test_data[i] = train_data[i].fillna(&quot;None&quot;)</span><br><span class="line">    </span><br><span class="line">test_data[&#x27;GarageYrBlt&#x27;] = test_data[&#x27;GarageYrBlt&#x27;].fillna(0)</span><br><span class="line">test_data[&#x27;MasVnrType&#x27;] = test_data[&#x27;MasVnrType&#x27;].fillna(&#x27;SBrkr&#x27;)</span><br><span class="line">test_data[&#x27;Exterior1st&#x27;] = test_data[&#x27;Exterior1st&#x27;].fillna(test_data[&quot;Exterior1st&quot;].mode()[0])</span><br><span class="line">test_data[&#x27;Exterior2nd&#x27;] = test_data[&#x27;Exterior2nd&#x27;].fillna(test_data[&quot;Exterior2nd&quot;].mode()[0])</span><br><span class="line">test_data[&#x27;MSZoning&#x27;] = test_data.groupby(&#x27;MSSubClass&#x27;)[&#x27;MSZoning&#x27;].transform(lambda x: x.fillna(x.mode()[0]))</span><br><span class="line">test_data[&#x27;SaleType&#x27;] = test_data[&#x27;SaleType&#x27;].fillna(test_data[&#x27;SaleType&#x27;].mode()[0])</span><br><span class="line">test_data[&#x27;LotFrontage&#x27;] = test_data.groupby(&#x27;Neighborhood&#x27;)[&#x27;LotFrontage&#x27;].transform(lambda x:x.fillna(x.median()))</span><br><span class="line">test_data[&#x27;MasVnrArea&#x27;] = test_data[&#x27;GarageYrBlt&#x27;].fillna(0)</span><br><span class="line">test_data[&#x27;BsmtFullBath&#x27;] = test_data[&#x27;BsmtFullBath&#x27;].fillna(0)</span><br><span class="line">#test_data.drop([&#x27;Utilities&#x27;],axis=1,inplace=True)</span><br><span class="line">for i in [&#x27;BsmtHalfBath&#x27;,&#x27;GarageArea&#x27;,&#x27;BsmtFinSF1&#x27;,&#x27;BsmtFinSF2&#x27;,&#x27;GarageCars&#x27;]:</span><br><span class="line">    test_data[i] = test_data[i].fillna(0)</span><br><span class="line">for i in [&#x27;TotalBsmtSF&#x27;,&#x27;BsmtUnfSF&#x27;]:</span><br><span class="line">    test_data[i] = test_data[i].fillna(0)</span><br><span class="line">    </span><br><span class="line">train_data = train_data.drop([&#x27;Utilities&#x27;, &#x27;Street&#x27;, &#x27;PoolQC&#x27;,], axis=1)</span><br><span class="line">test_data = test_data.drop([&#x27;Utilities&#x27;, &#x27;Street&#x27;, &#x27;PoolQC&#x27;,], axis=1)</span><br></pre></td></tr></table></figure><p>（这里我们可以将训练集和测试集先进行合并然后进行数据预处理，可以减少一部分代码量）</p><h3 id="数据转化"><a href="#数据转化" class="headerlink" title="数据转化"></a>数据转化</h3><p>缺失值经过填充，我们的数据集（某些特征值）已经可以进行预测了，虽然正确率可能并不高，但不会因为空值报错，我们还要对数据进行下一步的整理。</p><ul><li><p>1：对一些数值型数据转化为字符串（我们后面还要对非数值型数据进行编码，我们认为这一部分数据作为编码对于模型的贡献要优于数值）<br>MSSubClass:建筑类<br>MoSold:已售出月份<br>YrSold:已售出年份<br>可能有人会问，那么房子的建设日期等一些其他的为什么不做转化-答案很简单，因为其他的分布杂乱，后面的编码会出现很多的空列，所以没有必要当然也可以这么做，自己取舍就可以了。</p></li><li><p>2：数据的转化（有时也做正规化等等），有时候数据的分布并不符合我们的预期，这个时候我们为了使其更好的匹配模型，就要进行对应的转化，常用的有取log log1p等，对于变量的分布我们可以通过绘图来观察。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scipy.stats import norm</span><br><span class="line">final_data[&#x27;SalePrice&#x27;] = np.log(final_data[&#x27;SalePrice&#x27;])</span><br><span class="line">sns.distplot(final_data[&#x27;SalePrice&#x27;],fit=norm) #黑色的线是norm曲线，正态分布下的图像</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(final_data[&#x27;SalePrice&#x27;],plot=plt)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/bAJqDx0.png"></p></li></ul><p>一是密度分布图，反应数据的大概分布。如果相差过大我们就需要对其进行对应的转化（这里已经进行了处理）<br>第二幅图是概率分布图，同理如果分布匹配不好我们需要进行转化，使其满足线性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sns.distplot(a=train_data.OverallQual,kde=True,fit=norm)</span><br><span class="line">train_data[&#x27;SalePrice&#x27;] = np.log(train_data[&#x27;SalePrice&#x27;])</span><br><span class="line">train_data[&#x27;GrLivArea&#x27;] = np.log(train_data[&#x27;GrLivArea&#x27;])</span><br><span class="line">train_data[&#x27;1stFlrSF&#x27;] = np.log(train_data[&#x27;1stFlrSF&#x27;])</span><br><span class="line">train_data[&#x27;TotRmsAbvGrd&#x27;] = np.log(train_data[&#x27;TotRmsAbvGrd&#x27;])</span><br><span class="line"></span><br><span class="line">test_data[&#x27;GrLivArea&#x27;] = np.log(test_data[&#x27;GrLivArea&#x27;])</span><br><span class="line">test_data[&#x27;1stFlrSF&#x27;] = np.log(test_data[&#x27;1stFlrSF&#x27;])</span><br><span class="line">test_data[&#x27;TotRmsAbvGrd&#x27;] = np.log(test_data[&#x27;TotRmsAbvGrd&#x27;])</span><br></pre></td></tr></table></figure><ul><li>3：离群值</li></ul><p>通过绘制散点图，我们可以找出一些明显偏离正常轨迹的点，这些需要除去促进模型的训练。<br><img src="https://i.imgur.com/ceEtHlp.png"><br><img src="https://i.imgur.com/wjXbmz4.png"><br>边缘点就是我们需要处理的值。</p><p>· 字符型数据的编码，我们收集的数据不限于数值型数据，为了更好的预测我们需要对这些数据进行编码</p><p>我们可以选择pandas 的 get_dummies() 或者sklearn的OneHotEncoder() 大同小异</p><p>那么我们现在的数据处理完了吗。答案是没有，没错还没有。<br>我们还可以对数据的特征值进行整合，或者增加一些新列等等（ps:特征工程)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#特征值合并</span><br><span class="line">train_data[&#x27;haspool&#x27;] = train_data[&#x27;PoolArea&#x27;].apply(lambda x:1 if x&gt; 0 else 0)</span><br><span class="line">train_data[&#x27;has2ndfloor&#x27;] = train_data[&#x27;2ndFlrSF&#x27;].apply(lambda x:1 if x&gt; 0 else 0)</span><br><span class="line">train_data[&#x27;hasgarage&#x27;] = train_data[&#x27;GarageArea&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line">train_data[&#x27;hasbsmt&#x27;] = train_data[&#x27;TotalBsmtSF&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line">train_data[&#x27;hasfireplace&#x27;] = train_data[&#x27;Fireplaces&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line"></span><br><span class="line">test_data[&#x27;haspool&#x27;] = test_data[&#x27;PoolArea&#x27;].apply(lambda x:1 if x&gt; 0 else 0)</span><br><span class="line">test_data[&#x27;has2ndfloor&#x27;] = test_data[&#x27;2ndFlrSF&#x27;].apply(lambda x:1 if x&gt; 0 else 0)</span><br><span class="line">test_data[&#x27;hasgarage&#x27;] = test_data[&#x27;GarageArea&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line">test_data[&#x27;hasbsmt&#x27;] = test_data[&#x27;TotalBsmtSF&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line">test_data[&#x27;hasfireplace&#x27;] = test_data[&#x27;Fireplaces&#x27;].apply(lambda x:1 if x&gt;0 else 0)</span><br><span class="line"></span><br><span class="line">train_data[&#x27;Total_porch_sf&#x27;] = (train_data[&#x27;OpenPorchSF&#x27;] + train_data[&#x27;3SsnPorch&#x27;] + train_data[&#x27;EnclosedPorch&#x27;]</span><br><span class="line">                               + train_data[&#x27;ScreenPorch&#x27;] + train_data[&#x27;WoodDeckSF&#x27;])</span><br><span class="line">train_data[&#x27;Total_Bathrooms&#x27;] = train_data[&quot;FullBath&quot;]+(0.5*train_data[&#x27;HalfBath&#x27;]) + train_data[&#x27;BsmtFullBath&#x27;] + (0.5*train_data[&#x27;BsmtHalfBath&#x27;])</span><br><span class="line">train_data[&#x27;Total_sqr_footage&#x27;] = train_data[&#x27;BsmtFinSF1&#x27;] + train_data[&#x27;BsmtFinSF2&#x27;]+train_data[&#x27;1stFlrSF&#x27;]+train_data[&#x27;2ndFlrSF&#x27;]</span><br><span class="line">train_data[&#x27;YearBuiltandRemod&#x27;] = train_data[&#x27;YearBuilt&#x27;] + train_data[&#x27;YearRemodAdd&#x27;]</span><br><span class="line"></span><br><span class="line">test_data[&#x27;Total_porch_sf&#x27;] = (test_data[&#x27;OpenPorchSF&#x27;] + test_data[&#x27;3SsnPorch&#x27;] + test_data[&#x27;EnclosedPorch&#x27;]</span><br><span class="line">                               + test_data[&#x27;ScreenPorch&#x27;] + test_data[&#x27;WoodDeckSF&#x27;])</span><br><span class="line">test_data[&#x27;Total_Bathrooms&#x27;] = test_data[&quot;FullBath&quot;]+(0.5*test_data[&#x27;HalfBath&#x27;]) + test_data[&#x27;BsmtFullBath&#x27;] + (0.5*test_data[&#x27;BsmtHalfBath&#x27;])</span><br><span class="line">test_data[&#x27;Total_sqr_footage&#x27;] = test_data[&#x27;BsmtFinSF1&#x27;] + test_data[&#x27;BsmtFinSF2&#x27;]+test_data[&#x27;1stFlrSF&#x27;]+test_data[&#x27;2ndFlrSF&#x27;]</span><br><span class="line">test_data[&#x27;YearBuiltandRemod&#x27;] = test_data[&#x27;YearBuilt&#x27;] + test_data[&#x27;YearRemodAdd&#x27;]</span><br></pre></td></tr></table></figure><p>那么现在完了吗？？？？<br>你可以先去试一下，然后可能会发现模型会报错，说呢多输入或者少输入一些列。<br>为什么呢，因为新的测试集中可能有一些新的字符数据,编码时形成了新的列（训练集中没有，所以就报错了）,当然如果你一开始就将两个表合并了那么当我没说。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final_test_data.drop([&#x27;MSSubClass_150&#x27;],axis=1,inplace=True)  ##通过查找这一列需要剔除，不会找怎么办？等他报错出来你就会了。</span><br></pre></td></tr></table></figure><p>这里还可以选择将一些大量为零的数据剔除，比如该列百分之99都是0，那么显然这个对结果影响不大。(记得删除Id列，他显然无用）</p><p>最后就可以选模型，调参数然后测试了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_model = xgb.XGBRegressor(learning_rate=0.01,n_estimators=3460,</span><br><span class="line">                                     max_depth=3, min_child_weight=0,</span><br><span class="line">                                     gamma=0, subsample=0.7,</span><br><span class="line">                                     colsample_bytree=0.7,</span><br><span class="line">                                     objective=&#x27;reg:linear&#x27;, nthread=-1,</span><br><span class="line">                                     scale_pos_weight=1, seed=27,</span><br><span class="line">                                     reg_alpha=0.00006,n_jobs=2)</span><br><span class="line">my_model.fit(final_train_data.as_matrix(),target.as_matrix(),verbose=False)</span><br><span class="line">print(np.sqrt(-cross_val_score(my_model,final_train_data.as_matrix(),target.as_matrix(),cv=10,scoring=&#x27;neg_mean_squared_error&#x27;)).mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from sklearn.linear_model import Lasso</span><br><span class="line">lasso = Lasso(alpha =0.001, random_state=1,max_iter=1e7)</span><br><span class="line">lasso.fit(final_train_data,target)</span><br><span class="line">print(np.sqrt(-cross_val_score(lasso,final_train_data,target,cv=10,scoring=&#x27;neg_mean_squared_error&#x27;)).mean())</span><br></pre></td></tr></table></figure><p>乱七八糟懵完了一篇博客，还是觉得kaggle上的内核写的比较好,我就是个弟弟，放上链接<br><a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/discussion/90688#latest-528810">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/discussion/90688#latest-528810</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程，线程，异步协程</title>
      <link href="/2019/03/18/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B/"/>
      <url>/2019/03/18/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文记录一下自己观看很多博客后，多余线程，进程，协程的理解。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>狭义的进程可以代表一个应用程序的执行过程，比如我们打开任务管理器，可以看到很多程序在运行，这些都可以都可以说是一个个进程。</p><p>广义的进程指的是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><p>进程的概念主要有两点</p><ul><li>进程是一个实体，每一个进程都有其自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。</li><li>进程是”执行中的程序”，一个程序不运行就是个空壳，只有经过运行，让处理器赋予其地址，给其生命，它才是一个实体，也就是一个进程。</li></ul><p>进程的状态</p><ul><li>就绪，指其获取了除CPU之外的所有资源，只要CPU分配资源就可以运行。</li><li>运行，也就是就绪之后获得了CPU分配的资源，可以执行操作</li><li>阻塞，当条件不足（比如说缺少某些插件，资源之类）此时称为阻塞态。</li></ul><p>进程的特征</p><ul><li>动态性，进程是程序的一次执行，有其生命期，不是永生的</li><li>并发行，任何进程都可以和其他进程一起执行（一个健壮的程序不止一个进程，只能同时运行一个程序的电脑和板砖有什么区别）</li><li>独立性，进程是系统进行资源分配和调度的一个独立单位</li><li>进程由程序、数据和进程控制块三部分组成。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p><ul><li>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</li><li>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了，于是就发明了线程。</li></ul><p>线程特征：</p><ul><li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；</li><li>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>通常程序至少一个进程，一个进程最少一个线程，进程是分配资源的最小单位，线程是CPU调度的最小单位。</li><li>资源（内存、寄存器等）分配给进程，进程在执行过程拥有独立的内存空间，而同一进程下的所有线程共享所有资源，从而提高程序的运行效率；</li><li>处理机分配给线程，即处理机真正运行的是线程；</li><li>线程在执行过程中，需要协作同步。不同线程间的要利用通信协议来实现同步。</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，使用一个线程去完成多个任务，可以理解成微线程。</p><p>协程的调度完全由用户控制，相对独立，有自己的上下文。一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被阻塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非阻塞的且没有相互依赖，协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高。</p><p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程</p><p>注：协程不是真正的多线程。</p><h3 id="多进程？多线程？"><a href="#多进程？多线程？" class="headerlink" title="多进程？多线程？"></a>多进程？多线程？</h3><p>前文说到，进程是操作系统进行资源分配的最小单位，那么在同一时间，同一设备，运行至少两个的进程，这就是多任务操作系统（不然怎么满足大众需求）<br>那么这里就出现问题了，我们人不能一心二用，而一直模仿人类的计算机显然也不可以，原则上一个CPU只能分配资源给一个进程，但我们常用的电脑都是单CPU,怎么实现多进程的呢，这就是“并发”。具体理论很复杂，可以理解为轮流使用CPU,每个进程只占用几毫秒，以人类的反应速度是无法感觉出来，实现一种很多进程同时运行的假象，但同一时间只有一个进程获得了CPU的使用权，多核CPU可以实现同时运行多个进程即——并行。但显然我们电脑的CPU数目远远小于我们运行的任务数，那么——并发还需仔细研究。</p><p>在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。<br>但由于共享资源，如果多个线程同时运行，而且访问同一个资源，那么就会报错。所以就有了所谓的“锁”，线程运行时将资源锁定，执行结束再释放，使其他线程来使用这部分资源，所以多线程的程序可以充分的利用CPU的资源，大大减少响应的时间，使得运行效率大大提高，而且由于使用统一的内存，减少了数据的传送困难，方便不同任务的协调操作和运行，数据交互问题会更容易解决。</p><p>多进程和多线程，是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p><pre><code>   要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。          如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。    如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。   多进程 优点 是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。    多进程 缺点 是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。还有一个不足之处，多进程下程序与各进程之间的通信和数据共享不方便；    多线程 优点 通常比多进程快一点，但是也快不到哪去，开销小！    多线程主要是为了节约CPU时间，为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率！    多线程 缺点 任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</code></pre><p>多任务操作系统(如Windows)的基本原理是：操作系统将CPU的时间片分配给多个线程，每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的)。操作系统不断的从一个线程的执行切换到另一个线程的执行，如此往复，宏观上看来,就好像是多个线程在一起执行。由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务。</p><p>那么多任务并发，可以充分发挥CPU资源，那么是不是并发量越大越好。当然不是，因为切换任务需要一定的消耗，少的时候看不出来，当达到某个临界值，那么卡顿就伴随而来。</p><ul><li>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</li></ul><h3 id="I-x2F-O-以及同步异步"><a href="#I-x2F-O-以及同步异步" class="headerlink" title="I&#x2F;O 以及同步异步"></a>I&#x2F;O 以及同步异步</h3><p>IO在计算机中指Input&#x2F;Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。但由于硬件等的差距，两者的运行效率是不一样的，甚至差距很大，这时有两种方式。</p><ul><li>同步，即CPU等待程序完成任务，再继续其他操作</li><li>异步，即把当前任务挂载，CPU去执行其他任务</li></ul><p>显然异步很优秀，但异步编程模型相对复杂，异步IO复杂度远远高于同步</p><p>同步</p><pre><code>    同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。    按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。    但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。    最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对处理完消息之前，这个函数不返回。    当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</code></pre><p>异步的概念和同步相对</p><pre><code>    当一个异步过程调用发出后，调用者不会立刻得到结果。    实际处理这个调用的部件是在调用发出后，    通过状态、通知来通知调用者，或通过回调函数处理这个调用。    考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。    现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。    对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</code></pre><h2 id="嗯，其实还有阻塞，非阻塞"><a href="#嗯，其实还有阻塞，非阻塞" class="headerlink" title="嗯，其实还有阻塞，非阻塞"></a>嗯，其实还有阻塞，非阻塞</h2><p>这是程序等待消息时的状态，不妨想一下同步异步是什么。</p><ul><li>阻塞调用是指结果返回之前，进程会被挂起，函数得到结果后才能返回（注，阻塞不等同于同步）</li><li>非阻塞就是未得到结果之前，该函数不会阻塞当前进程，而立即返回</li></ul><h3 id="其实他们还可以结合"><a href="#其实他们还可以结合" class="headerlink" title="其实他们还可以结合"></a>其实他们还可以结合</h3><p>同步阻塞</p><ul><li>效率最低，拿排队来说，就是你专心排队，什么事都不能做。（同步-排队这个进程，阻塞-未排到自己事件不返回）</li></ul><p>异步阻塞</p><ul><li>即排队领号之后的人，它不能离开太远也就是被阻塞在这个任务，因为你要等待被叫号（即等待消息解除阻塞状态）</li></ul><p>同步非阻塞</p><ul><li>效率也不高，还是排队，这次你可以做别的事了，比如玩个手机，但你要是不是注意是否排到了自己，两种行为切换很多次。</li></ul><p>异步非阻塞</p><ul><li>效率最高，你可以任意做其他事（异步），然后坐等柜台通知你去办理业务（非阻塞，未被阻塞在等待的操作上）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔密码</title>
      <link href="/2019/03/10/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81/"/>
      <url>/2019/03/10/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>希尔密码是基于矩阵的线性变换,其最大的好处就是隐藏了字符的频率信息, 使得传统的通过字频来破译密文的方法失效。（例如维吉尼亚密码等都有统计规律）</p><p>加密者在对明文加密前会选择一个加密秘匙, 这个秘匙最终会以一个m矩阵的形式参与到加密算法中的. 在加密者选定了加密秘匙后, m便得到了确定,这时,加密者将明文按m个字母一组的形式分成多组, 最后一组不足m个字母的按特定的方式补齐. 这样就形成了很多组由m个字母组成的单个向量, 然后对每一个m阶向量, 我们用它去乘以确定好了的秘匙.</p><p>如下为其中的一个分组A向量加密后变为B向量的过程:[A1,A2,A3 … Am] * M &#x3D; [B1,B2,B3 … Bm] .<br>我们将所有相乘后的向量连在一起, 便得到了密文. 这便是希尔密码的加密. </p><h3 id="密钥选取"><a href="#密钥选取" class="headerlink" title="密钥选取"></a>密钥选取</h3><p>我们可以随便取矩阵作为密钥吗，当然不可能。需要两个先决条件</p><ul><li>矩阵为非奇异矩阵（即det(A) !&#x3D; 0)</li><li>gcd(det(A),26) &#x3D; 1<br>也就是说在模26的运算上密钥矩阵的值需要和26互质。选择非奇异矩阵是为了解密操作，没有逆矩阵我们就无法进行解密，那么这个加密算法就没有任何价值。</li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>利用线性代数的知识我们可以清晰的知道解密只需要乘上密钥的逆矩阵即可，那么逆矩阵怎么求呢。</p><ul><li>一是使用伴随矩阵, 通过计算行列式得到. 所用公式为: M^-1 &#x3D; M^* &#x2F; D . (其中M^*为M的伴随矩阵, D为M的行列式的值)</li></ul><p>伴随矩阵是和逆矩阵相似的一个概念，将我们的余子矩阵（准确的来说是代数余子式矩阵）转置就可以得到<img src="https://i.imgur.com/mrjwdcH.png">,然后将伴随矩阵乘以 1&#x2F;（det(A)) 就可以得到逆矩阵。</p><p>ps: 这里说的是纯线性代数知识，1&#x2F;(det(A)) 在数论中可不是简单的取倒数，而是求乘法逆元。</p><ul><li>二是通过增广矩阵, 在M右侧附加一个n阶单位矩阵, 再通过初等变换将增广矩阵的左侧变换为一个n阶单位矩阵, 这时右侧便是我们需要的逆矩阵，这样会有一个缺点，比如这个矩阵： M &#x3D; [[3,6],[2,7]] 它的逆矩阵为[[7&#x2F;9,2&#x2F;3].[-2&#x2F;9,1&#x2F;3]] 这个是不符合我们的要求的因为会损失精度，这可是绝对不可以出现的情况，这时就要采取其他的方法。</li></ul><p>那么对于我们的例子直接乘9可以吗，显然这不可能。这里因为我们是Z26的字母表. 我们要保证乘以一个数之后, 原来的明文字母所增大的部分一定得是26的整数倍.<br>（1）设x为扩大倍数 a为字符 t 为整数，则有 a<em>x &#x3D; a + 26</em>t； t &#x3D; a(x-1)&#x2F;26 那么x &#x3D; 26*p + 1 (p为整数）我们取p &#x3D; 1即可，则x&#x3D;27. 那么推广到矩阵就可以得知我们要乘的那个数字为（27，det(A))——27和矩阵值的最小公倍数。</p><p>（2）这个方法参见看雪论坛<a href="https://bbs.pediy.com/thread-89505.htm" title="看雪">https://bbs.pediy.com/thread-89505.htm</a></p><p>具体代码实现就不写了，参见<a href="https://blog.csdn.net/kanamisama0/article/details/60836382">https://blog.csdn.net/kanamisama0/article/details/60836382</a></p><p>ps： 求逆矩阵的伴随矩阵方法参考这个例子<a href="https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html">https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转轮密码机</title>
      <link href="/2019/03/09/%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%E6%9C%BA/"/>
      <url>/2019/03/09/%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>转轮密码机是多表代换密码的典型例子，在二战中广泛应用。分为三个轮子-快中慢，每次敲击一次字符轮子就会转动一次，从而打破了明文密文的固定代替关系。快轮子转动26次-即循环了字母表则中轮子会转动一个字符，整个密码机的周期为26<em>26</em>26.</p><p><img src="https://camo.githubusercontent.com/095c4fbde6c9fdbde144dc229c477cc2d0e488cd/68747470733a2f2f7777342e73696e61696d672e636e2f6c617267652f303036744e6252776c793166646d346636756961326a3330676f30626d3074792e6a7067"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ElemType fgear[2][26] = &#123; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26&#125;,&#123;8, 18, 26, 17, 20, 22, 10, 3, 13, 11, 4, 23, 5, 24, 9, 12, 25, 16, 19, 6, 15, 21, 2, 7, 1, 14&#125; &#125;;  //快轮</span><br><span class="line">ElemType mgear[2][26] = &#123; &#123;26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25&#125;,&#123;20, 1, 6, 4, 15, 3, 14, 12, 23, 5, 16, 2, 22, 19, 11, 18, 25, 24, 13, 7, 10, 8, 21, 9, 26, 17&#125; &#125;; //中轮</span><br><span class="line">ElemType sgear[2][26] = &#123; &#123;24, 25, 26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;,&#123;21, 3, 15, 1, 19, 10, 14, 26, 20, 8, 16, 7, 22, 4, 11, 5, 17, 9, 12, 23, 18, 2, 25, 6, 24, 13&#125; &#125;;  //慢轮</span><br></pre></td></tr></table></figure><p>我们密码机的初态定义如上，应用循环链表来把初态输入我们的程序。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Gear;   //主类</span><br><span class="line">class Node &#123;</span><br><span class="line">private:</span><br><span class="line">ElemType leftElement;</span><br><span class="line">ElemType rightElement;</span><br><span class="line">Node *<span class="built_in">link</span>;</span><br><span class="line">friend class Gear;</span><br><span class="line">&#125;;  //链表类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们具体需要什么方法来实现呢，要有移动轮子的 move() 方法，还有把初态密码机输入程序的 InitGear() 方法，寻找每个轮子左列与输入下标相同的元素的 Search()方法， 当然右列也一样 Find() 方法，当然还有不可缺少的构造函数和析构函数（实际是完成Node链表的初始化和销毁）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Gear &#123;</span><br><span class="line">public:</span><br><span class="line"><span class="function"><span class="title">Gear</span></span>() &#123; first = NULL; &#125;                //构造函数</span><br><span class="line">~Gear();                                //析构函数</span><br><span class="line">void initGear(ElemType data[2][26]);</span><br><span class="line">bool Find(ElemType <span class="keyword">in</span>, ElemType &amp;x) const;      //查找每个轮子左列与输入下标相同的元素的值</span><br><span class="line">ElemType Search(ElemType x) const;              //查找每个轮子右列与输入元素值相同的元素的下标</span><br><span class="line">bool move();                                    //每加密一个字母，旋转一下轮子</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Node *first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Gear::move()  //</span><br><span class="line">&#123;</span><br><span class="line">Node *p = first;</span><br><span class="line"><span class="keyword">for</span> (ElemType i = 0; i &lt; 25; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;<span class="built_in">link</span>;</span><br><span class="line">&#125;</span><br><span class="line">first = p;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Gear::~<span class="function"><span class="title">Gear</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">Node *p=first-&gt;<span class="built_in">link</span>,*q;   //令p指向first的下一位，最后释放first指针</span><br><span class="line"><span class="keyword">while</span> (p!=first) &#123;</span><br><span class="line">q = p-&gt;<span class="built_in">link</span>;</span><br><span class="line">first-&gt;<span class="built_in">link</span> = q;</span><br><span class="line">delete p;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">delete first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Gear::initGear(ElemType data[2][26])</span><br><span class="line">&#123;</span><br><span class="line">Node *p=first, *q;</span><br><span class="line">p = first;</span><br><span class="line"><span class="keyword">for</span> (ElemType i = 0; i &lt; 26; i++)</span><br><span class="line">&#123;</span><br><span class="line">q = new Node;   //创建新节点</span><br><span class="line">q-&gt;leftElement = data[0][i];</span><br><span class="line">q-&gt;rightElement = data[1][i];</span><br><span class="line"><span class="keyword">if</span> (i == 0)</span><br><span class="line">&#123;</span><br><span class="line">first = q;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i==25)  //实现首尾相连</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;<span class="built_in">link</span> = q;</span><br><span class="line">p = q;</span><br><span class="line">q-&gt;<span class="built_in">link</span> = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;<span class="built_in">link</span> = q;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType Gear::Search(ElemType x) const</span><br><span class="line">&#123;</span><br><span class="line">Node *p = first;</span><br><span class="line">ElemType i;</span><br><span class="line"><span class="keyword">for</span> (i = 0; p &amp;&amp; p-&gt;rightElement != x; ++i) &#123;    //从第一个元素开始查找，一直到 p 指向 NULL 或 p 指向的节点的 element 值与 x 相等</span><br><span class="line">p = p-&gt;<span class="built_in">link</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;        //若 p 不指向 NULL，<span class="built_in">return</span> 当前下标</span><br><span class="line"><span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool Gear::Find(ElemType <span class="keyword">in</span>,ElemType &amp;x) const</span><br><span class="line">&#123;</span><br><span class="line">Node *p;</span><br><span class="line">p = first;</span><br><span class="line"><span class="keyword">for</span> (ElemType i = 0; i &lt; <span class="keyword">in</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;<span class="built_in">link</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = p-&gt;leftElement;  //利用x返回此时的值</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ElemType Encode(ElemType <span class="keyword">in</span>, Gear *gFast, Gear *gMiddle, Gear *gSlow) </span><br><span class="line">&#123;</span><br><span class="line">ElemType x, result;</span><br><span class="line">gSlow-&gt;Find(<span class="keyword">in</span>, x);</span><br><span class="line">result = gSlow-&gt;Search(x);</span><br><span class="line">gMiddle-&gt;Find(result, x);</span><br><span class="line">result = gMiddle-&gt;Search(x);</span><br><span class="line">gFast-&gt;Find(result, x);</span><br><span class="line">result = gFast-&gt;Search(x);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;   //加密函数，模拟轮子的电路操作一一对应。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里要停一下假如我们这样设置加密函数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ElemType Encode(ElemType <span class="keyword">in</span>, Gear gFast, Gear gMiddle, Gear gSlow) </span><br></pre></td></tr></table></figure><p>正常的传入我们的对象gFast,gMiddle,gSlow会发生什么 函数结束的时候对象会自动析构，要知道我们没有设置拷贝构造函数，但我们的对象中有动态空间（Node类，这里我们的Node附属于Gear的，会随着Gear消失而消失），就会发生指针指向NULL，从而GG程序宣告失败。这里用到的是C++的深浅拷贝问题以及函数的传参知识。</p><p>函数传参有三种传参方式：传值、传址、传引用。<br>1、按值传递<br>    （1）形参和实参各占一个独立的存储空间。<br>    （2）形参的存储空间是函数被调用时才分配的，调用开始，系统为形参开辟一个临时的存储区，然后将各实参传递给形参，这是形参就得到了实参的值。<br>2、地址传递<br>    地址传递与值传递的不同在于，它把实参的存储地址传送给形参，使得形参指针和实参指针指向同一块地址。因此，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。<br>3、引用传递<br>    引用传递是以引用为参数，则既可以使得对形参的任何操作都能改变相应数据，又使函数调用方便。引用传递是在形参调用前加入引用运算符“&amp;”。引用为实参的别名，和实参是同一个变量，则他们的值也相同，该引用改变则它的实参也改变。<br>注：引用是C++的概念，C中没有，同时布尔类型也是C++的概念。</p><p>那么我们的转轮密码机做完了吗，显然还没有。我们只是搭好了架子做好了轮子还没有组装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Encodeword(Gear gFast, Gear gMiddle, Gear gSlow) &#123;</span><br><span class="line"></span><br><span class="line">char plain[100], cipher[100];</span><br><span class="line">ElemType <span class="keyword">in</span>[100], out[100];</span><br><span class="line">ElemType i = 0;</span><br><span class="line">ElemType gf = 0, gm = 0;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入您要加密的内容（空格以&#x27;／&#x27;代替）: &quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">cin &gt;&gt; plain;</span></span><br><span class="line"><span class="string">ElemType n = (ElemType)(strlen(plain));</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;正在加密......\n&quot;;</span></span><br><span class="line"><span class="string">for (i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line"><span class="string">if (plain[i] &lt; 65 || plain[i] &gt; 122 || plain[i] == 91 || plain[i] == 92 || plain[i] == 93 || plain[i] == 94 || plain[i] == 95 || plain[i] == 96) &#123;</span></span><br><span class="line"><span class="string">cipher[i] = plain[i];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else &#123;</span></span><br><span class="line"><span class="string">if (plain[i] &gt;= 97 &amp;&amp; plain[i] &lt;= 122) &#123;</span></span><br><span class="line"><span class="string">in[i] = plain[i] - 32 - &#x27;A&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else &#123;</span></span><br><span class="line"><span class="string">in[i] = plain[i] - &#x27;A&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">out[i] = Encode(in[i], &amp;gFast, &amp;gMiddle, &amp;gSlow);</span></span><br><span class="line"><span class="string">cipher[i] = char(out[i] + &#x27;A&#x27;);</span></span><br><span class="line"><span class="string">gf++;</span></span><br><span class="line"><span class="string">gFast.move();</span></span><br><span class="line"><span class="string">if (gf == 26) &#123;</span></span><br><span class="line"><span class="string">gm++;</span></span><br><span class="line"><span class="string">gMiddle.move();</span></span><br><span class="line"><span class="string">gf = 0;</span></span><br><span class="line"><span class="string">if (gm == 26) &#123;</span></span><br><span class="line"><span class="string">gSlow.move();</span></span><br><span class="line"><span class="string">gm = 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cipher[i + 1] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;加密成功！密文是：&quot; &lt;&lt; endl</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">cipher;</span></span><br><span class="line"><span class="string">&#125;*/</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>有兴趣的可以自己写解密函数，还可以加上文件读写的功能使其可以对文件进行加密。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理的使用</title>
      <link href="/2018/12/07/%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/07/%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文记录一下代理的使用方法。</p><h2 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h2><p>代理有免费的和收费的。免费的一般很不稳定，可用率能有百分之10就不错了</p><p>国内有很多代理商，提供的代理质量也参差不齐，这里我们以阿步云为例，他提供两种隧道模式(协议的不同）。<br>1——http隧道</p><ul><li>专业版</li><li>动态版</li><li>经典版</li></ul><p>2——socks隧道</p><ul><li>经典版</li></ul><p>http使用较多，我们就以它为例来说。<br>专业版的代理会锁定一个ip 一分钟，到期后自动切换<br>动态版顾名思义，每次请求都会更换一个新的ip<br>经典版则是锁定一个ip 15分钟。</p><p>对于一个爬虫来说的话，更建议使用动态版，ip封禁后直接请求获取新的代理。<br>阿步云给了详细的接入文档。</p><p>下面列出一个python版的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line"># 要访问的目标页面</span><br><span class="line">targetUrl = &quot;http://test.abuyun.com/proxy.php&quot;</span><br><span class="line">#targetUrl = &quot;http://proxy.abuyun.com/switch-ip&quot;</span><br><span class="line">#targetUrl = &quot;http://proxy.abuyun.com/current-ip&quot;</span><br><span class="line"></span><br><span class="line"># 代理服务器</span><br><span class="line">proxyHost = &quot;proxy.abuyun.com&quot;</span><br><span class="line">proxyPort = &quot;9010&quot;</span><br><span class="line"></span><br><span class="line"># 代理隧道验证信息</span><br><span class="line">proxyUser = &quot;H01234567890123P&quot;</span><br><span class="line">proxyPass = &quot;0123456789012345&quot;</span><br><span class="line"></span><br><span class="line">proxyMeta = &quot;http://%(user)s:%(pass)s@%(host)s:%(port)s&quot; % &#123;</span><br><span class="line">    &quot;host&quot; : proxyHost,</span><br><span class="line">    &quot;port&quot; : proxyPort,</span><br><span class="line">    &quot;user&quot; : proxyUser,</span><br><span class="line">    &quot;pass&quot; : proxyPass,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy_handler = request.ProxyHandler(&#123;</span><br><span class="line">    &quot;http&quot;  : proxyMeta,</span><br><span class="line">    &quot;https&quot; : proxyMeta,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#auth = request.HTTPBasicAuthHandler()</span><br><span class="line">#opener = request.build_opener(proxy_handler, auth, request.HTTPHandler)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(proxy_handler)</span><br><span class="line"></span><br><span class="line"># opener.addheaders = [(&quot;Proxy-Switch-Ip&quot;, &quot;yes&quot;)]</span><br><span class="line">request.install_opener(opener)</span><br><span class="line">resp = request.urlopen(targetUrl).read()</span><br><span class="line"></span><br><span class="line">print (resp)</span><br></pre></td></tr></table></figure><p>有四个参数需要我们填入</p><ul><li>代理服务器</li><li>代理端口号</li><li>代理通行证书</li><li>代理通行密钥</li></ul><p>代理服务器和端口号三个版本各自不同且唯一，通行证书和密钥则是在你购买之后才会得到直接复制代码然后填入对应参数就可以了。<br>想要更多可以看这里  <a href="https://github.com/abuyun/proxy-demo/blob/master/python/python3/urllib/proxy-demo.py">https://github.com/abuyun/proxy-demo/blob/master/python/python3/urllib/proxy-demo.py</a></p><p>假如我们要用selenium来操纵浏览器那么如何给他配置代理呢。<br>这里我们只列举selenium + Chrome的方法</p><ul><li>不用授权验证的代理</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(&#x27;--proxy-server=http://ip:port&#x27;)  </span><br><span class="line">driver = webdriver.Chrome(executable_path=&quot;C:\chromedriver.exe&quot;, chrome_options=0ptions)</span><br><span class="line">driver.get(&quot;http://ip138.com/&quot;)</span><br><span class="line">print(driver.page_source)</span><br></pre></td></tr></table></figure><p>调用ChromeOptions这个接口把我们的代理ip放进去 然后再把参数传入我们的打开浏览器的接口里，这里注意一下————代码里的executable_path&#x3D;”C:\chromedriver.exe” 是我们chromedriver.exe所在的路径，如果我们已经把它放到了python的Scripts目录，那么可以省略这个参数。</p><ul><li>需要授权验证的代理</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">def create_proxyauth_extension(proxy_host, proxy_port,</span><br><span class="line">                               proxy_username, proxy_password,</span><br><span class="line">                               scheme=&#x27;http&#x27;, plugin_path=None):</span><br><span class="line">    &quot;&quot;&quot;代理认证插件</span><br><span class="line"></span><br><span class="line">    args:</span><br><span class="line">        proxy_host (str): 你的代理地址或者域名（str类型）</span><br><span class="line">        proxy_port (int): 代理端口号（int类型）</span><br><span class="line">        proxy_username (str):用户名（字符串）</span><br><span class="line">        proxy_password (str): 密码 （字符串）</span><br><span class="line">    kwargs:</span><br><span class="line">        scheme (str): 代理方式 默认http</span><br><span class="line">        plugin_path (str): 扩展的绝对路径</span><br><span class="line"></span><br><span class="line">    return str -&gt; plugin_path</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if plugin_path is None:</span><br><span class="line">        plugin_path = &#x27;vimm_chrome_proxyauth_plugin.zip&#x27;</span><br><span class="line"></span><br><span class="line">    manifest_json = &quot;&quot;&quot;</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">        &quot;manifest_version&quot;: 2,</span><br><span class="line">        &quot;name&quot;: &quot;Chrome Proxy&quot;,</span><br><span class="line">        &quot;permissions&quot;: [</span><br><span class="line">            &quot;proxy&quot;,</span><br><span class="line">            &quot;tabs&quot;,</span><br><span class="line">            &quot;unlimitedStorage&quot;,</span><br><span class="line">            &quot;storage&quot;,</span><br><span class="line">            &quot;&lt;all_urls&gt;&quot;,</span><br><span class="line">            &quot;webRequest&quot;,</span><br><span class="line">            &quot;webRequestBlocking&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;background&quot;: &#123;</span><br><span class="line">            &quot;scripts&quot;: [&quot;background.js&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;minimum_chrome_version&quot;:&quot;22.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    background_js = string.Template(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    var config = &#123;</span><br><span class="line">            mode: &quot;fixed_servers&quot;,</span><br><span class="line">            rules: &#123;</span><br><span class="line">              singleProxy: &#123;</span><br><span class="line">                scheme: &quot;$&#123;scheme&#125;&quot;,</span><br><span class="line">                host: &quot;$&#123;host&#125;&quot;,</span><br><span class="line">                port: parseInt($&#123;port&#125;)</span><br><span class="line">              &#125;,</span><br><span class="line">              bypassList: [&quot;foobar.com&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    chrome.proxy.settings.set(&#123;value: config, scope: &quot;regular&quot;&#125;, function() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    function callbackFn(details) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            authCredentials: &#123;</span><br><span class="line">                username: &quot;$&#123;username&#125;&quot;,</span><br><span class="line">                password: &quot;$&#123;password&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chrome.webRequest.onAuthRequired.addListener(</span><br><span class="line">                callbackFn,</span><br><span class="line">                &#123;urls: [&quot;&lt;all_urls&gt;&quot;]&#125;,</span><br><span class="line">                [&#x27;blocking&#x27;]</span><br><span class="line">    );</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ).substitute(</span><br><span class="line">        host=proxy_host,</span><br><span class="line">        port=proxy_port,</span><br><span class="line">        username=proxy_username,</span><br><span class="line">        password=proxy_password,</span><br><span class="line">        scheme=scheme,</span><br><span class="line">    )</span><br><span class="line">    with zipfile.ZipFile(plugin_path, &#x27;w&#x27;) as zp:</span><br><span class="line">        zp.writestr(&quot;manifest.json&quot;, manifest_json)</span><br><span class="line">        zp.writestr(&quot;background.js&quot;, background_js)</span><br><span class="line"></span><br><span class="line">    return plugin_path</span><br></pre></td></tr></table></figure><p>我们可以把这个写进单独的文件或者只作为一个函数,调用这个返回值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from common.pubilc import create_proxyauth_extension</span><br><span class="line"></span><br><span class="line">proxyauth_plugin_path = create_proxyauth_extension(</span><br><span class="line">    proxy_host=&quot;XXXXX.com&quot;,</span><br><span class="line">    proxy_port=9020,</span><br><span class="line">    proxy_username=&quot;XXXXXXX&quot;,</span><br><span class="line">    proxy_password=&quot;XXXXXXX&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">co = webdriver.ChromeOptions()</span><br><span class="line"># co.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line">co.add_extension(proxyauth_plugin_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(executable_path=&quot;C:\chromedriver.exe&quot;, chrome_options=co)</span><br><span class="line">driver.get(&quot;http://ip138.com/&quot;)</span><br><span class="line">print(driver.page_source)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以不用了解上面的代码是什么原理，会用就行，当然理解最好。</p><p>还有一些常规浏览器的代理使用方法，阿布云都有详细的文档<a href="https://www.abuyun.com/http-proxy/dyn-manual.html">https://www.abuyun.com/http-proxy/dyn-manual.html</a></p><p>然后什么代理好用呢，已经有大神自己做过评测了，想知道请移步<a href="https://cuiqingcai.com/5094.html">https://cuiqingcai.com/5094.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set</title>
      <link href="/2018/12/02/set/"/>
      <url>/2018/12/02/set/</url>
      
        <content type="html"><![CDATA[<p>本文记一下自己的程序设计周</p><h2 id="往set容器内插入自定义类（自定义排序函数）"><a href="#往set容器内插入自定义类（自定义排序函数）" class="headerlink" title="往set容器内插入自定义类（自定义排序函数）"></a>往set容器内插入自定义类（自定义排序函数）</h2><ul><li>需要重载（） 或者&lt; 运算符，虽然它内部自定义了排序函数，但是对于我们自定义的类它无法自主判断</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> bool USER::operator&lt;(const USER &amp; demo) const</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;GetId_number() == demo.GetId_number())  //通过比较身份证号码去重</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if (Age != demo.Age)//如果年龄不同按年龄升序排列，如果相同则按身份证号码升序排列。</span><br><span class="line">&#123;</span><br><span class="line">return Age &lt; demo.Age;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return Id_number &lt; demo.Id_number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果重载的是（）运算符那么是这样</span><br><span class="line">bool USER::operator()(const USER &amp; demo,const USER &amp; demo2) const</span><br><span class="line">&#123;</span><br><span class="line">if (demo-&gt;GetId_number() == demo2.GetId_number())  ////通过比较身份证号码去重</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if (demo.Age != demo2.Age)//如果年龄不同按年龄升序排列，如果相同则按身份证号码升序排列。</span><br><span class="line">&#123;</span><br><span class="line">return demo.Age &lt; demo2.Age;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return demo.Id_number &lt; demo2.Id_number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何对容器内对象进行更改"><a href="#如何对容器内对象进行更改" class="headerlink" title="如何对容器内对象进行更改"></a>如何对容器内对象进行更改</h2><p>放入<set>容器内的对象默认是不可更改的，是常对象。但一般我们还是需要对其更改，这时候我们只有采取先删除这个元素然后添加新元素的方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;USER&gt;::iterator p = user.begin();  </span><br></pre></td></tr></table></figure><p>这里是我自己定义的类USER,user为已经保存数据的<set>,采取生成迭代器方法，然后令指针指向容器的第一个元素。（注，begin()&#x2F;end()不会检查容器是否为空，可用empty()检查）<br>begin()和end()是指向第一个元素和最后一个元素吗？？<br><img src="https://i.imgur.com/8g6ibTO.png"><br>有些博客上说end()是最后一个元素，其实是错的。end()指向最后一个元素之后为空的部分</p><p>删除元素-erase()  ps-需要加一个判断，如果指针指向了容器的end()，没有办法删除操作。<br>添加元素-insert() ps-不要忘记自定义排序函数</p><p>补一句既然是常对象，那么如果你要定义类函数访问他的某个属性，那么函数必须为常函数。</p><p>其他常见函数见<a href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyquery解析库</title>
      <link href="/2018/11/26/pq/"/>
      <url>/2018/11/26/pq/</url>
      
        <content type="html"><![CDATA[<p>本文简单的讲解一下Pyquery的简单操作。</p><h2 id="Pyquery简介"><a href="#Pyquery简介" class="headerlink" title="Pyquery简介"></a>Pyquery简介</h2><p>pyquery allows you to make jquery queries on xml documents. The API is as much as possible the similar to jquery. pyquery uses lxml for fast xml and html manipulation.</p><p>This is not (or at least not yet) a library to produce or interact with javascript code. I just liked the jquery API and I missed it in python so I told myself “Hey let’s make jquery in python”. This is the result.</p><p>It can be used for many purposes, one idea that I might try in the future is to use it for templating with pure http templates that you modify using pyquery. I can also be used for web scrapping or for theming applications with Deliverance.</p><p>The project is being actively developped on a git repository on Github. I have the policy of giving push access to anyone who wants it and then to review what he does. So if you want to contribute just email me.</p><p>Please report bugs on the github issue tracker.</p><p>Jquery: a jquery-like library for python </p><h2 id="安装Pyquery"><a href="#安装Pyquery" class="headerlink" title="安装Pyquery"></a>安装Pyquery</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyquery</span><br></pre></td></tr></table></figure><p>需要lxml,如果没有安装这个请自行安装</p><h2 id="初始化Pyquery"><a href="#初始化Pyquery" class="headerlink" title="初始化Pyquery"></a>初始化Pyquery</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pyquery import PyQuery as pq  #导入Pyquery起别名为pq</span><br></pre></td></tr></table></figure><h3 id="加载html字符串"><a href="#加载html字符串" class="headerlink" title="加载html字符串"></a>加载html字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc = pq(&quot;&lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;font-size: 14px; line-height: 1.6; font-family: 微软雅黑, sans-serif;&quot;&gt;从前你以为军训休息时你可以尽情休息&lt;/span&gt;&lt;/p&gt;&quot;)</span><br></pre></td></tr></table></figure><h3 id="加载指定路径下的html文件"><a href="#加载指定路径下的html文件" class="headerlink" title="加载指定路径下的html文件"></a>加载指定路径下的html文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc = pq(&quot;C://**//**//demo.html&quot;)   我自己尝试报错了，懒得查看原因</span><br></pre></td></tr></table></figure><h3 id="加载指定url的html-即可以直接跳过requests请求，直接一步得到）"><a href="#加载指定url的html-即可以直接跳过requests请求，直接一步得到）" class="headerlink" title="加载指定url的html(即可以直接跳过requests请求，直接一步得到）"></a>加载指定url的html(即可以直接跳过requests请求，直接一步得到）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc = pq(url = &quot;http://www.baidu.com&quot;)</span><br><span class="line">也可以改变请求头。</span><br><span class="line">pq(&#x27;http://cuiqingcai.com/&#x27;, headers=&#123;&#x27;user-agent&#x27;: &#x27; &#x27;&#125;)</span><br><span class="line">post请求也不在话下。</span><br><span class="line">pq(&#x27;http://httpbin.org/post&#x27;, &#123;&#x27;foo&#x27;: &#x27;bar&#x27;&#125;, method=&#x27;post&#x27;, verify=True)</span><br></pre></td></tr></table></figure><p>一般我们只用第一种，下面两种很少使用。</p><h2 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h2><p>提取方法由很多种，熟悉jquery就会有无限可能，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can use some of the pseudo classes that are available in jQuery but that are not standard in css such as :first :last :even :odd :eq :lt :gt :checked :selected :file:</span><br><span class="line">&gt;&gt;&gt; d(&#x27;p:first&#x27;)</span><br><span class="line">[&lt;p#hello.hello&gt;]    这里不多做演示</span><br></pre></td></tr></table></figure><p>再比如我们可以采取jquery API的形式操作我们的属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p = pq(&#x27;&lt;p id=&quot;hello&quot; class=&quot;hello&quot;&gt;&lt;/p&gt;&#x27;)(&#x27;p&#x27;)</span><br><span class="line">&gt;&gt;&gt; p.attr(&quot;id&quot;)</span><br><span class="line">&#x27;hello&#x27;</span><br><span class="line">&gt;&gt;&gt; p.attr(&quot;id&quot;, &quot;plop&quot;)</span><br><span class="line">[&lt;p#plop.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; p.attr(&quot;id&quot;, &quot;hello&quot;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line"></span><br><span class="line">如果你觉得这个不适应，我们还有稍微更Python一点的东西</span><br><span class="line">&gt;&gt;&gt; p.attr.id = &quot;plop&quot;</span><br><span class="line">&gt;&gt;&gt; p.attr.id</span><br><span class="line">&#x27;plop&#x27;</span><br><span class="line">&gt;&gt;&gt; p.attr[&quot;id&quot;] = &quot;ola&quot;</span><br><span class="line">&gt;&gt;&gt; p.attr[&quot;id&quot;]</span><br><span class="line">&#x27;ola&#x27;</span><br><span class="line">&gt;&gt;&gt; p.attr(id=&#x27;hello&#x27;, class_=&#x27;hello2&#x27;)</span><br><span class="line">[&lt;p#hello.hello2&gt;]</span><br><span class="line">&gt;&gt;&gt; p.attr.class_</span><br><span class="line">&#x27;hello2&#x27;</span><br><span class="line">&gt;&gt;&gt; p.attr.class_ = &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>我们经常会用到CSS选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用CSS操纵class</span><br><span class="line">&gt;&gt;&gt; p.addClass(&quot;toto&quot;)</span><br><span class="line">[&lt;p#hello.hello.toto&gt;]</span><br><span class="line">&gt;&gt;&gt; p.toggleClass(&quot;titi toto&quot;)</span><br><span class="line">[&lt;p#hello.hello.titi&gt;]</span><br><span class="line">&gt;&gt;&gt; p.removeClass(&quot;titi&quot;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">使用CSS操纵style</span><br><span class="line">&gt;&gt;&gt; p.css(&quot;font-size&quot;, &quot;15px&quot;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; p.attr(&quot;style&quot;)</span><br><span class="line">&#x27;font-size: 15px&#x27;</span><br><span class="line">&gt;&gt;&gt; p.css(&#123;&quot;font-size&quot;: &quot;17px&quot;&#125;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; p.attr(&quot;style&quot;)</span><br><span class="line">&#x27;font-size: 17px&#x27;</span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">python一点的方法</span><br><span class="line">&gt;&gt;&gt; p.css.font_size = &quot;16px&quot;</span><br><span class="line">&gt;&gt;&gt; p.attr.style</span><br><span class="line">&#x27;font-size: 16px&#x27;</span><br><span class="line">&gt;&gt;&gt; p.css[&#x27;font-size&#x27;] = &quot;15px&quot;</span><br><span class="line">&gt;&gt;&gt; p.attr.style</span><br><span class="line">&#x27;font-size: 15px&#x27;</span><br><span class="line">&gt;&gt;&gt; p.css(font_size=&quot;16px&quot;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; p.attr.style</span><br><span class="line">&#x27;font-size: 16px&#x27;</span><br><span class="line">&gt;&gt;&gt; p.css = &#123;&quot;font-size&quot;: &quot;17px&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; p.attr.style</span><br><span class="line">&#x27;font-size: 17px&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们还可以通过它来添加元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">末尾插入</span><br><span class="line">&gt;&gt;&gt; d = pq(&#x27;&lt;p class=&quot;hello&quot; id=&quot;hello&quot;&gt;you know Python rocks&lt;/p&gt;&#x27;)</span><br><span class="line">&gt;&gt;&gt; d(&#x27;p&#x27;).append(&#x27; check out &lt;a href=&quot;http://reddit.com/r/python&quot;&gt;&lt;span&gt;reddit&lt;/span&gt;&lt;/a&gt;&#x27;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; print(d)</span><br><span class="line">&lt;p class=&quot;hello&quot; id=&quot;hello&quot;&gt;you know Python rocks check out &lt;a href=&quot;http://reddit.com/r/python&quot;&gt;&lt;span&gt;reddit&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">当然也可以在前面插入</span><br><span class="line">&gt;&gt;&gt; p = d(&#x27;p&#x27;)</span><br><span class="line">&gt;&gt;&gt; p.prepend(&#x27;check out &lt;a href=&quot;http://reddit.com/r/python&quot;&gt;reddit&lt;/a&gt;&#x27;)</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; p.html()</span><br><span class="line">&#x27;check out &lt;a href=&quot;http://reddit.com/r/python&quot;&gt;reddit&lt;/a&gt;you know ...&#x27;</span><br><span class="line"></span><br><span class="line">定位节点插入也不是不可能</span><br><span class="line">&gt;&gt;&gt; d = pq(&#x27;&lt;html&gt;&lt;body&gt;&lt;div id=&quot;test&quot;&gt;&lt;a href=&quot;http://python.org&quot;&gt;python&lt;/a&gt; !&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;)</span><br><span class="line">&gt;&gt;&gt; p.prependTo(d(&#x27;#test&#x27;))</span><br><span class="line">[&lt;p#hello.hello&gt;]</span><br><span class="line">&gt;&gt;&gt; d(&#x27;#test&#x27;).html()</span><br><span class="line">u&#x27;&lt;p class=&quot;hello&quot; ...&#x27;</span><br></pre></td></tr></table></figure><p>删除元素也很简单</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = pq(&#x27;&lt;html&gt;&lt;body&gt;&lt;p id=&quot;id&quot;&gt;Yeah!&lt;/p&gt;&lt;p&gt;python rocks !&lt;/p&gt;&lt;/div&gt;&lt;/html&gt;&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.remove(&#x27;p#id&#x27;)</span><br><span class="line">[&lt;html&gt;]</span><br><span class="line">&gt;&gt;&gt; d(&#x27;p#id&#x27;)</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d(&#x27;p&#x27;).empty()</span><br><span class="line">[&lt;p&gt;]</span><br></pre></td></tr></table></figure><p>还有一些其他的操作这里不在细说，自己去参阅文档吧<a href="https://pythonhosted.org/pyquery/traversing.html">https://pythonhosted.org/pyquery/traversing.html</a></p><p>下面就该说说爬虫常用到的了</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>以CSS选择器为选择标志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">content = doc(&quot;CSS选择器内容&quot;)</span><br><span class="line"></span><br><span class="line">生成迭代器，</span><br><span class="line">content = doc(&quot;CSS选择器内容&quot;).items()</span><br><span class="line">获取文本</span><br><span class="line">content = doc(&quot;CSS选择器内容&quot;).text()</span><br><span class="line"></span><br><span class="line">获取标签内的链接</span><br><span class="line">content = doc(&quot;CSS选择器内容&quot;).attr(&#x27;href&#x27;)  #如果这个选择器选出的对象唯一，否则需要遍历</span><br><span class="line"></span><br><span class="line">其他不在多说。</span><br></pre></td></tr></table></figure><p>补一句，前两天再写爬虫的时候，它会把嵌入的播放器页面的闭合标签（</iframe>)自动去除，会有一些错误。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT</title>
      <link href="/2018/11/25/QT/"/>
      <url>/2018/11/25/QT/</url>
      
        <content type="html"><![CDATA[<p>本文简单的说一下，Qt一些坑。</p><h2 id="文字兼容问题"><a href="#文字兼容问题" class="headerlink" title="文字兼容问题"></a>文字兼容问题</h2><p>由于字符编码的储存不一样，Qt的中文显示会出现一些问题（如果仅仅是让它在代码里显示中文的话，打开时选择一下字符编码就好了）</p><p>解决办法如下（含一些已经失效的办法）</p><ul><li>先将对应的cpp文件用windows自带的记事本打开，另存为UTF-8格式，然后在代码中，遇到中文字符，使用QStringLiteral(“中文”)进行修饰<br>这种方式每次新建一个class就要切出去用记事本编辑一下实在麻烦，而且每个中文字符串都要用QStringLiteral来修饰，实在麻烦</li><li>在头文件申明中加上<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>一切OK了</li></ul><p>但方法二已经废弃了，只可以用在QT5的最初几个版本。</p><p>此外还有一些办法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString str1=QStringLiteral(&quot;中文字符&quot;);  </span><br><span class="line">QString str2=QString::fromLocal8bit(&quot;中文字符&quot;);  </span><br><span class="line">QString str3=QString::fromWCharArray(L&quot;中文字符&quot;);  </span><br><span class="line">QString str4=u8&quot;中文字符&quot;;    //好像这种方法只适合C++11以上版本</span><br></pre></td></tr></table></figure><p>不过这些办法貌似还是没能解决我的问题——分别用QT和VS2017读取文本数据，中文就会变为一些奇妙的东西。（ps_暂时未找到合适的办法，以上是我网上找了好多博客总结的办法，当然最简单的就是你其中一个打开就好了）</p><h2 id="多界面切换问题"><a href="#多界面切换问题" class="headerlink" title="多界面切换问题"></a>多界面切换问题</h2><p>主界面（Widget) 对话框（Dialog)也可以称为子界面</p><p>对于一个界面我们有这么几种操作可以做</p><ul><li>close()  关闭界面，如果是主界面那么直接退出程序</li><li>hide()  隐藏界面，一般用于界面转换的时候，由主界面转向子界面</li><li>show()  显示一个界面<br>以及一些其他的更改界面大小之类的操作</li></ul><p>当我们从主界面跳转至子界面<br>主界面中我们这么写ps– this-&gt;hide();new-&gt;exec();this-&gt;show();<br>子界面可以</p><ul><li>槽函数clicked() 和 accept();</li><li>close();</li></ul><p>这里说一下show() 和 exec()的区别</p><h3 id="show-非模式对话框"><a href="#show-非模式对话框" class="headerlink" title="show()非模式对话框"></a>show()非模式对话框</h3><p>显示一个非模式对话框。控制权即刻返回给调用函数。<br>弹出窗口是否模式对话框，取决于modal属性的值。<br>（原文：Shows the dialog as a modeless dialog. Control returns immediately to the calling code. The dialog will be modal or modeless according to the value of the modal property. ）<br><img src="https://img-blog.csdn.net/20160405192916896"></p><h3 id="exec-模式对话框"><a href="#exec-模式对话框" class="headerlink" title="exec()模式对话框"></a>exec()模式对话框</h3><p>显示一个模式对话框，并且锁住程序直到用户关闭该对话框为止。函数返回一个DialogCode结果。<br>在对话框弹出期间，用户不可以切换同程序下的其它窗口，直到该对话框被关闭。<br>（原文：Shows the dialog as a modal , blocking until the user closes it. The function returns a DialogCode result.<br>Users cannot interact with any other window in the same application until they close the dialog. ）<br><img src="https://img-blog.csdn.net/20160405193105350"></p><p>也就是说如果是exec()那么只有这个操作结束返回之后才会进行下一步操作，也就是阻塞（开启一个事件循环，所谓事件循环，可以理解成一个无限循环。Qt 在开启了事件循环之后，系统发出的各种事件才能够被程序监听到。这个事件循环相当于一种轮询的作用。既然是无限循环，当然在开启了事件循环的地方，代码就会被阻塞，后面的语句也就不会被执行到。因此，对于使用了exec()显示的模态对话框，我们可以在exec()函数之后直接从对话框的对象获取到数据值。）<br>通俗的说就是运用exec()之后我们只有对这个对话框完成操作后才能进行其他的，而show()则可以同时进行其他操作（默认情况下）。<br>exec()是有返回值的，QDialog::Accepted  or  QDialog::Rejected<br>当然我们调用槽函数accept() 也可以在show()中达到这个操作。</p><h2 id="显示数据可直接更改问题。"><a href="#显示数据可直接更改问题。" class="headerlink" title="显示数据可直接更改问题。"></a>显示数据可直接更改问题。</h2><p>ui-&gt;tableView-&gt;setEditTriggers(QTableView::NoEditTriggers); 设置不可编辑成功这是只针对TableView的。其他的也类似。</p><p>先说说如何显示数据吧，有三种</p><ul><li>Table View (即以表格的形式显示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要引用QStandardItemModel头文件</span><br><span class="line">QStandardItemModel  *model = new QStandardItemModel();</span><br><span class="line">model-&gt;setColumnCount(7);   //设置列数</span><br><span class="line">    model-&gt;setHeaderData(0,Qt::Horizontal,QString::fromStdString(&quot;XX&quot;));   //设置每列的名称</span><br><span class="line">    model-&gt;setHeaderData(1,Qt::Horizontal,QString::fromStdString(&quot;XX&quot;));</span><br><span class="line">    model-&gt;setHeaderData(2,Qt::Horizontal,QString::fromStdString(&quot;XXX&quot;));</span><br><span class="line">    model-&gt;setHeaderData(3,Qt::Horizontal,QString::fromStdString(&quot;XX&quot;));</span><br><span class="line">    model-&gt;setHeaderData(4,Qt::Horizontal,QString::fromStdString(&quot;XX&quot;));</span><br><span class="line">    model-&gt;setHeaderData(5,Qt::Horizontal,QString::fromStdString(&quot;XX&quot;));</span><br><span class="line">    model-&gt;setHeaderData(6,Qt::Horizontal,QString::fromStdString(&quot;XXX&quot;));</span><br><span class="line">    ui-&gt;tableView-&gt;setModel(model);  //在界面中显示我们设置的表格</span><br><span class="line">    当然也可以逐个读取</span><br><span class="line">QStringList headers;</span><br><span class="line">headers &lt;&lt; &quot;ID&quot; &lt;&lt; &quot;Name&quot; &lt;&lt; &quot;Age&quot; &lt;&lt; &quot;Sex&quot;;</span><br><span class="line">tableWidget.setHorizontalHeaderLabels(headers);</span><br><span class="line"></span><br><span class="line">读入数据</span><br><span class="line">ui-&gt;tableView-&gt;setEditTriggers(QTableView::NoEditTriggers);</span><br><span class="line">    for(int i = 0;i &lt; 7;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;tableView-&gt;setColumnWidth(i,70);  设置宽度</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;USER&gt;::iterator p = Index::user.begin();</span><br><span class="line">    model-&gt;removeRows(0,model-&gt;rowCount());   //删除行，也就是初始化显示界面</span><br><span class="line">    for(int i = 0;i &lt; Index::user.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        model-&gt;setItem(i,0,new QStandardItem(QString::fromStdString(p-&gt;GetName())));</span><br><span class="line">        model-&gt;setItem(i,1,new QStandardItem(QString::fromStdString(p-&gt;GetSex())));</span><br><span class="line">        model-&gt;setItem(i,2,new QStandardItem(QString::fromStdString(p-&gt;GetId_number())));</span><br><span class="line">        model-&gt;setItem(i,3,new QStandardItem(QString::number(p-&gt;GetAge())));</span><br><span class="line">        model-&gt;setItem(i,4,new QStandardItem(QString::fromStdString(p-&gt;GetAddress())));</span><br><span class="line">        model-&gt;setItem(i,5,new QStandardItem(QString::fromStdString(p-&gt;GetCareer())));</span><br><span class="line">        model-&gt;setItem(i,6,new QStandardItem(QString::fromStdString(p-&gt;GetPhone_number())));</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">具体看你自己的程序</span><br><span class="line"></span><br><span class="line">- List View (即以列表的形式）</span><br><span class="line">- </span><br><span class="line">QStringList user;</span><br><span class="line">user += &quot;first&quot;;</span><br><span class="line">user +=&quot;second&quot;;</span><br><span class="line">QStringListModel *model = new QStringListModel(user);</span><br><span class="line">userList-&gt;setModel(model);        //userList是个QListView</span><br><span class="line">user += &quot;third&quot;;</span><br><span class="line">model-&gt;setStringList(user);</span><br><span class="line">model-&gt;removeRows(0,model-&gt;rowCount());//从第0行开始，删除所有行</span><br><span class="line">model-&gt;removeRows(0,2);//从第0行开始，删除前2行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- Tree View (即以树状图形式）</span><br><span class="line">这个比较详细 我不在多说</span><br><span class="line">[http://www.it165.net/pro/html/201405/14029.html](http://www.it165.net/pro/html/201405/14029.html)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>以后再做补充</p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法</title>
      <link href="/2018/10/31/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/31/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍一下Logistic回归中寻找最优化系数的梯度下降算法。</p><hr><h2 id="何为回归拟合"><a href="#何为回归拟合" class="headerlink" title="何为回归拟合"></a>何为回归拟合</h2><p>假设现在有一些数据点，我们用一条直线对这些点进行拟合（该线称为最佳拟合直线），这个拟合过程就称作回归。利用Logistic回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归”一词源于最佳拟合，表示要找到最佳拟合参数集。训练分类器时的做法就是寻找最佳拟合参数，使用的是最优化算法。</p><p>我们以二分类为例，也就是将你的数据集分为0-1两类，我们要尽可能的确保他们的分类正确率，使我们的错误率下降到最低。我们需要找到一个合适的函数，对我们的输入数据可以分成两类。</p><h2 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2><p>先来介绍一个函数，在两个类的情况下，函数输出0或1。或许你之前接触过具有这种性质的函数，该函数称为海维塞德阶跃函数（Heaviside step function），或者直接称为单位阶跃函数。但这个函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程有时很难处理。 幸好另一个函数也有相似的性质，没错就是Sigmoid函数:<br>y &#x3D; 1&#x2F;(1+e<sup>-z</sup>)<br>函数图像如图所示：</p><p><img src="https://i.imgur.com/3f3zYvL.png"></p><p>可见在区间足够大的时候，很像阶跃函数，数学上也很好处理。当x&#x3D;0时，函数值为0.5，当x&gt;0,函数值直线上升接近1；x&lt;0时则急速下降至0附近。</p><hr><p>回到我们的分类器上来，既然找到了这么一个可以解决我们问题的函数，那么我们就为了实现Logistic回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5即被归入0类。现在这个分类器的关键在于如何找到一个最佳的回归系数，也到了引入我们的梯度下降算法的时候的。</p><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>运用梯度下降算法我们需要输入我们所有的特性值。形式如下：</p><p>h(x) &#x3D; w<sub>0</sub>*x<sub>0</sub> + w<sub>1</sub>*x<sub>1</sub> + …….+ w<sub>n</sub>*x<sub>n</sub></p><p>[w<sub>0</sub>,w<sub>1</sub>,…….w<sub>n</sub>] 为我们要的回归系数向量<br>而x<sub>0</sub>…….x<sub>n</sub> 为我们的特征值向量。<br>我们怎么应用它呢，这时要引入另一个函数了：代价函数。</p><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p><img src="https://i.imgur.com/l5pUHaQ.png"></p><p>代价函数也就是我们的特征值经过h(x)进行运算之后得到的值与真值进行对比，我们采取平方和来定义这个函数，m个数据集的预测值与真实值差的平方和，除以数据集数目的2倍，这就是我们代价函数的定义。<br><img src="https://i.imgur.com/O00cSVL.png"><br>代价函数的下降是用初始的向量值减去（学习率乘代价函数的偏导数），从而得到我们的新的代价函数，一般是逐渐下降的接近与0的时候我们的最佳回归系数也就确定了。 随着代价函数的下降，其实和我们梯度下降一个道理，以同样的形式对回归系数进行更新。</p><p>代价函数是我们判断这个回归系数怎么样的一个标准，代价函数越小那么我们的回归系数就越适合，也就意味着我们的分类器的正确率也就越高，因此这是一个非常重要的函数。</p><h3 id="如何界定最佳系数"><a href="#如何界定最佳系数" class="headerlink" title="如何界定最佳系数"></a>如何界定最佳系数</h3><p>算法已经完成，那么我们怎么确定一个值让他停下呢。我们有几种思路：</p><ul><li>通过设定一个阈值，当我们的代价函数小于这个值的时候，我们就中止算法，选择这时的回归系数。</li><li>设定循环次数，界定一个循环次数，因为阈值很难界定，我们不知道这个阈值需要进行多久的运算，也许我们某个学习率下代价函数不可能小于阈值，那么我们的实验就失败了，因此设定一个循环次数是一般采用的方法。</li></ul><h4 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h4><p>我们的数据不总是合适的，一个数据集的特征值千差万别，比如我们的房屋面积和房屋年龄，两个数据大概是几十倍，相差这么大的数据会让我们的算法出现很大的难度，所以我们需要进行数据归一化。简单的介绍两种</p><ul><li>特征值缩放-我们取出每种特征值的最大值和最小值，然后让每个特征值减去最小值，再除去最大值和最小值的差，然后就可以得到0-1的特征值向量</li><li>均值归一化，取出每种特征值的最大最小值和平均值，让每个特征值减去平均值，然后除去最大值最小值的差，即完成均值归一化</li></ul><h4 id="如何选择合适的学习率呢"><a href="#如何选择合适的学习率呢" class="headerlink" title="如何选择合适的学习率呢"></a>如何选择合适的学习率呢</h4><p>一个合适的学习率，能够让我们很快的得到最佳回归系数；一个很烂的学习率，也许会让我们的代价函数越来越大，越来越偏离我们的最佳回归系数，如图所示：<br><img src="https://i.imgur.com/yVSbXWC.png"></p><p>学习率太小的话，我们的代价函数需要经过很久很久的循环才能下降到合适值；学习率过大则会使我们的代价函数出现很大的波动，因此学习率真的很重要，只有通过多次实验观察才能找到合适的值，一般我们采用0.001，0.01,0.1为学习率，适当修改就可以满足需要。</p><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>最佳回归系数只有通过梯度下降（上升）吗，当然不是我们还有一个正规方程可以用，形式如下：<br><img src="https://i.imgur.com/V18bBz8.png"><br>这么一个方程就可以完成最佳回归系数的求解，当然它也是有局限性的，因为如果我们的特征值很多，数据集很大，上万条数据，那么我们进行矩阵的运算，就会对电脑造成很大的负担，很难得到最终结果，计算复杂度太大。这里展示一下梯度下降(上升）法，和正规方程的利与弊：<br><img src="https://i.imgur.com/9FQaAvY.png"></p><p>具体选择还需多多实践，通常如果数据集乘特征值的量不超过万，那么正规方程是个良好的选择，不过一般真正的数据下，还是梯度算法更有意义。</p><p>本文不在贴代码，简单的介绍，还需多加实践。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三感故事</title>
      <link href="/2018/10/23/gudu/"/>
      <url>/2018/10/23/gudu/</url>
      
        <content type="html"><![CDATA[<p>刷朋友圈的时候，看到一条由三感音乐故事拍摄的短视频，被文案戳中了泪点。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>22岁生日，一个人吃火锅，还好锅底可以点最辣的；187次路过的码头，4次遇到一对情侣，两个人眼中的风景，也不见得更好看；第6次 一个人搬家，扔掉了3箱旧东西，很遗憾，好像连回忆也一并被丢弃了。<br>8点场的电影，48块的双人套餐，两杯可乐一个人喝，喝到的心情都有点丧丧的；第12次一个人输液，200ml的药水，一共2386滴，37分钟滴完，但痛了很久；一个人过生日，8寸的蛋糕，颜色有5种。</p><p>看到这些，我不由得联想到自己的状态。</p><p>住学校周转房的11楼，因为没有通电梯，同事们都没搬进去，那一层只有我一个人。尽管房子花了四五万装修，买了沙发茶几，装了电视，贴了墙纸，但还是没有家的感觉。</p><p>有电冰箱、零食柜，但里面都是空的；有微波炉、电磁炉，但从来没用过。</p><p>家里一共6盏灯，现在已经坏了4盏，我没想着去修一下。于我而言，黑暗冷清和灯火通明，并没有什么区别。</p><p>每周五下午开始，就没人再和我说话，等到周日晚上返校开班会的时候，前五分钟的讲话连吐字都不清楚，需要重新练习发声。</p><p>我也渴望被理解，但我讨厌去解释。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>一个人生活，细细数来已经快10年了。</p><p>背井离乡到外地求学，毕业后在冰冷的钢筋森林里打拼。学着在一个陌生的环境中，处理人际关系，打理生活琐事，去应对生活里的各种暴击。</p><p>一个人吃饭，点两菜一汤，老板不愿浪费，自作主张少炒了一道菜。一个人吃火锅，服务员反复强调要按两人份收钱，不然他们就亏了。</p><p>一个人去KTV，开了间包厢，唱了好多遍《好久不见》和《盛夏的果实》，想唱《屋顶》没人陪，叫来包房公主，但她不喜欢周杰伦。</p><p>一个人去医院，住的地方叫不到车，已经吐到连胃酸都没得吐了，还要强撑着开车，难受的时候靠边停一会儿，即便头晕目眩也要保持清醒底线，得分清刹车和油门。</p><p>一个人吃烧烤，豆角、花菜、豆腐串、烤肉、韭菜、茄子、鱼片，每次都必点，老板已经很熟悉了，去的时候会安排和别人拼桌，然后直接把单子报一遍。</p><p>一个人旅行，下榻在桂林，那夜雷雨，全区停电。起初因为雷电太响，就躲得离窗户远一些。后来干脆拉开窗帘，坐在窗台上，眼前一片漆黑，只有闪电在天空肆意纵横，雨势滂沱，雷声滚滚。</p><p>我想着那些黑洞洞的窗口里，人们都蜷缩躲着，就忽而觉得这是一场盛宴，美得惊心动魄，不药可救。</p><p>人生中大部分时候，我都无比厌恶自己，那一刻我觉得自己很棒。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>2018年的第一天，我看到一个大四的小姑娘在朋友圈许愿：“我的新年愿望，是希望能买一台全自动洗衣机，实在不想碰冰水了。”</p><p>那是我用刀片划拉手腕重生的第二天，我决定帮她实现愿望。</p><p>我让她下单后找我代付，很快就看见她更新朋友圈：“新年愿望达成，再也不用碰冰水了。”</p><p>前些天，我又看到她一个人去一个偏远的地方上班，打不到车，叫不了外卖。住的地方什么也没有，生活用品和铺盖都得自己张罗，做到年底可以拿4千块。</p><p>她找我诉苦：“太冷了，太孤独了，太荒凉了，原本是想毕业了不好意思再让父母养着就出来试试，说不定以后还可以考到这里工作，没想到这么艰难，突然就迷茫了。”</p><p>我说：“不要迷茫，要想清楚，如果只为赚那点工资，就早点撤离，生活和感情一样，都需要及时止损。一天都忍受不了的人，别想着可以将就一辈子。一天都呆不下去的地方，别想着可以凑合一辈子。”</p><p>她说：“可是我不想回家，我妈知道我辞职会杀了我。”</p><p>我说：“那你回学校准备考工作，就考你想去的地方，经过这样一番折腾，你应该就有动力复习了。”</p><p>她说：“可是我没有车费。”</p><p>于是，我又给她转了4千块。</p><p>转完钱我就把她拉黑了，因为我并不关心她以后过得怎么样。我肯帮她，只是庆幸自己好不容易熬过那个冰冷的夜晚，想在这样一个寒冷的冬天，给陌生人施与一些暖意。</p><p>她辞职后，应该会一个人把买好的东西打包好，再搬回学校，应该会一个人做饭、看书、刷题，工作考了一次又一次，然后被无情刷掉。</p><p>可是，这些都没什么大不了，生命中有一段严重孤独的时光是好事。它得隔绝外界的打扰和帮助，是一个人从培养社会性转向自我探索的非常好的契机。</p><p>经过这个过程，你可以完成对自己的重新评估，学会信任自己，习惯独自行动，看轻外部评价，实现人生的种种可能。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>电影《冈仁波齐》中，有一个镜头让我很感动。一个朝圣者趴在地上，看着一只蚂蚁缓缓在他面前爬过。</p><p>我感动的点，不是他给一只蚂蚁让路，毕竟这种行为沾染了都市文明中马路文化的傲慢。我感动的，是他“意识”到蚂蚁的存在，那是一只蚂蚁，不是一个1厘米不到的黑点图形。</p><p>在他意识到蚂蚁的那一刻，他的孤独是有质感的，因为他感受到了大自然中其他生命的繁忙。</p><p>那朱雀桥边，乌衣巷口， 金陵玉树，秦淮水榭，多少热闹是非成败，转头都变成了英雄冢。可是海滩的岩石，巍峨的高山，奔腾的激流 ，却从来都是那样，他们孤独而不朽。</p><p>孤独真的很糟糕吗？我很喜欢短片里的回答。</p><p>其实，什么样的状态，都总是有寂寞、失落、安静、绝望的日子。</p><p>你离群索居，独自前行，是因为你知道所谓孤独，不过是害怕孤独，于是你耐住了寂寞，挨过了失落，学会了安静，扛住了绝望。</p><p>寂寞是一种情绪，孤独是一种境境界。人终要是走出咖啡屋，尘世的喜怒哀乐的冲击往往更加强烈，更让人难以忘怀。</p><p>只有耐得住寂寞，忍得了孤独，你才能让心静下来，学到更多的东西，获得独一份的成长。</p><p>世界上没有两片相同的树叶，没有什么比自己陪伴自己，更让人幸福。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>生而为人，我们太喜欢形式上的丰盈，并在无人问津的时刻变得脆弱，这是对自己不负责任的表现。</p><p>一个人来时，不管他身后多么丰盈，早晚也要独自面对这个世界，完全依靠自己内心的力量存活下去。</p><p>千万不要一遇到困难，就慌不择路到处找人求助，不敢自由思考和独立行动。千万不要刚探出一点头，又被几句外界评价打消，迅速缩回安全但逼仄的壳里。</p><p>正如短片里说的那样，所谓孤独，不过是一场无人送粥的重感冒。疼总是外界给的，但病总是自己好的。我要放肆吃喝，放肆笑闹，我要跟我的灵魂说话，我孤独但我不寂寞。</p><p>要么孤独，要么庸俗。扛得住孤独，世界才能被你左右。</p><p>作者：衷曲无闻<br>BGM：再见我的爱人<br>來源：简书</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-网页基础</title>
      <link href="/2018/10/21/class0-1/"/>
      <url>/2018/10/21/class0-1/</url>
      
        <content type="html"><![CDATA[<p>本文讲一下网页的基本组成、结构、节点等内容。</p><h2 id="网页的构成"><a href="#网页的构成" class="headerlink" title="网页的构成"></a>网页的构成</h2><p>网页由三大部分，HTML,CSS,JavaScript,我们把网页比作一个人的话，HTML 相当于骨架，JavaScript 则相当于肌肉，CSS 则相当于皮肤，三者结合起来才能形成一个完善的网页</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML 是用来描述网页的一种语言，其全称叫做 Hyper Text Markup Language，即超文本标记语言。网页包括文字、按钮、图片、视频等各种复杂的元素，其基础架构就是 HTML。不同类型的文字通过不同类型的标签来表示，如图片用 img 标签表示，视频用 video 标签来表示，段落用 p 标签来表示，它们之间的布局又常通过布局标签 div 嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>HTML 定义了网页的结构，但是只有 HTML 页面的布局会不美观，可能只是简单的节点元素的排列，那么为了让网页看起来更好看一点，在这里就借助于 CSS。<br>CSS，全称叫做 Cascading Style Sheets，即层叠样式表。“层叠”是指当在 HTML 中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head_wrapper.s-ps-islite .s-p-top &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 40px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 181px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个 CSS 样式，在大括号前面是一个 CSS 选择器，此选择器的意思是选中 id 为 head_wrapper 且 class 为 s-ps-islite 内部的 class 为 s-p-top 的元素。大括号内部写的就是一条条样式规则，例如 position 指定了这个元素的布局方式为绝对布局，bottom 指定元素的下边距为 40 像素，width 指定了宽度为 100% 占满父元素，height 则指定了元素的高度。也就是说我们将一些位置、宽度、高度等样式配置统一写成这样的形式，大括号括起来，然后开头再加上一个 CSS 选择器，就代表这一个样式对 CSS 选择器选中的元素生效，这样元素就会根据此样式来展示了。<br>所以在网页中，一般会统一定义整个网页的样式规则，写入到 CSS 文件，其后缀名为 css，在 HTML 中只需要用 link 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观优雅。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript，简称为 JS，是一种脚本语言，HTML 和 CSS 配合使用，提供给用户的只是一种静态的信息，缺少交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是 JavaScript 的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。<br>JavaScript 通常也是以单独的文件形式加载的，后缀名为 js，在 HTML 中通过 script 标签即可引入</p><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;<span class="built_in">head</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">        &lt;title&gt;This is a Demo&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div <span class="built_in">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line">                &lt;h2 class=<span class="string">&quot;title&quot;</span>&gt;Hello World&lt;/h2&gt;</span><br><span class="line">                &lt;p class=<span class="string">&quot;text&quot;</span>&gt;Hello, this is a paragraph.&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这就是一个最简单的 HTML 实例，开头是 DOCTYPE 定义了文档类型，其次最外层是 html 标签，最后还有对应的结尾代表标签闭合，其内部是 head 标签和 body 标签，分别代表网页头和网页体，它们也分别需要尾标签表示闭合。head 标签内定义了一些页面的配置和引用，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>定义了字符编码为UTF-8。<br>其他不在赘述，很简单。</p><h2 id="节点及节点关系"><a href="#节点及节点关系" class="headerlink" title="节点及节点关系"></a>节点及节点关系</h2><p>在 HTML 中，所有标签定义的内容都是节点，它们构成了一个 HTML DOM 树。（我们在开发者工具中见到的都是DOM树结构的代码）<br>DOM，英文全称 Document Object Model，即文档对象模型。它定义了访问 HTML 和 XML 文档的标准W3C DOM 标准被分为 3 个不同的部分：<br>1-核心 DOM - 针对任何结构化文档的标准模型<br>2-XML DOM - 针对 XML 文档的标准模型<br>3-HTML DOM - 针对 HTML 文档的标准模型<br>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<br>1-整个文档是一个文档节点<br>2-每个 HTML 元素是元素节点<br>3-HTML 元素内的文本是文本节点<br>4-每个 HTML 属性是属性节点<br>5-注释是注释节点<br>HTML DOM 将 HTML 文档视作树结构，这种结构被称为节点树<br>通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 节点元素均可被修改，也可以被创建或删除。<br>节点树中的节点彼此拥有层级关系。我们常用 parent（父）、child（子）和 sibling（兄弟）等术语用于描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。<br>在节点树中，顶端节点被称为根（root），除了根节点之外每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。(数据库的最高权限用户为Root一样的道理，是根的意思）</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>在 CSS 中是使用了 CSS 选择器来定位节点的，例如上例中有个 div 节点的 id 为 container，那么我们就可以用 CSS 选择器表示为 #container，# 开头代表选择 id，其后紧跟 id 的名称。另外如果我们想选择 class 为 wrapper 的节点，便可以使用 .wrapper，. 开头代表选择 class，其后紧跟 class 的名称。另外还有一种选择方式是根据标签名筛选，例如我们想选择二级标题，直接用 h2 即可选择。如上是最常用的三种选择表示，分别是根据 id、class、标签名筛选，请牢记它们的写法。<br>另外 CSS 选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如 #container .wrapper p 则代表选择 id 为 container 内部的 class 为 wrapper 内部的 p 节点。另外如果不加空格则代表并列关系，如 div#container .wrapper p.text 代表选择 id 为 container 的 div 节点内部的 class 为 wrapper 节点内部的 class 为 text 的 p 节点。这就是 CSS 选择器，其筛选功能还是非常强大的：<br>具体请自行查阅官方文档。</p><h2 id="Session-和-cookies"><a href="#Session-和-cookies" class="headerlink" title="Session 和 cookies"></a>Session 和 cookies</h2><p>不知有没有人考虑过，服务器是怎么知道我们是否登录的，为什么有时候长时间未操作的已登陆界面会自己退出登陆。这些都要归功于他们。<br>上面我们贴了一段最简单的Html代码，我们将其保存为一个 html 文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx 等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面了，这就搭建了一个最简单的网站。<br>这种网页的内容是 HTML 代码编写的，文字、图片等内容均是通过写好的 HTML 代码来指定的，这种页面叫做静态网页。这种网页加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL 灵活多变地显示内容等,和后台没有交互，不能满足我们的需求，只能看不能玩的花架子。<br>所以动态网页应运而生，它可以动态解析 URL 中参数的变化，关联数据库并动态地呈现不同的页面内容，非常灵活多变，我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python 等语言编写的，功能相比静态网页强大和丰富太多太多。<br>动态网站还可以实现用户登录注册的功能，再回到开篇提到的问题，很多页面是需要登录之后才可以查看的，按照一般的逻辑来说，我们输入用户名密码登录之后，肯定是拿到了一种类似凭证的东西，有了它我们才能保持登录状态，才能访问登录之后才能看到的页面</p><h3 id="无状态Http"><a href="#无状态Http" class="headerlink" title="无状态Http"></a>无状态Http</h3><p>在了解 Session 和 Cookies 之前，我们还需要了解 HTTP 的一个特点，叫做无状态.</p><p>HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。当我们向服务器发送一个 Requset 后，服务器解析此 Request，然后返回对应的 Response，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是说它左耳朵进右耳朵出，并没有把我们的事件放在心里。特别是需要登陆的系统，想象一下，每次操作都要登陆，多么刺激！！！！</p><p>这时候，两个用于保持 HTTP 连接状态的技术就出现了，它们分Session 和 Cookies，Session 在服务端，也就是网站的服务器，用来保存用户的会话信息，Cookies 在客户端，也可以理解为浏览器端，有了 Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的 Response。<br>它们唯一对应，理解为Cookies是一个包含你信息的档案袋，有了它学校就知道你大概做过了什么，是不是本校的学生。（栗子不恰当请见谅）</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session，即会话，其本来的含义是指有始有终的一系列动作&#x2F;消息，比如你大学本科从报名到拿到毕业证的过程。<br>而在 Web 中 Session 对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。（比如你的本科学生证享受的优惠只持续四年(杠精说编级的我也没办法))。</p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而储存在用户本地终端上的数据。</p><p>主要用来和服务器验证我们做了什么。当客户端第一次请求服务器时，服务器会返回一个 Headers 中带有 Set-Cookie 字段的 Response 给客户端，用来标记是哪一个用户，客户端浏览器会把Cookies 保存起来。当浏览器下一次再请求该网站时，浏览器会把此Cookies 放到 Request Headers 一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session 是什么，然后再判断 Session 来以此来辨认用户状态。</p><p>登陆后服务器的Session会和你的cookies匹配，如果某些变量有效系统就是认为你是登陆的用户，给你返回相应的资源，但这是有时间限制的，如果传给服务器的 Cookies 是无效的，或者 Session 已经过期了，我们将不能继续访问页面，可能会收到错误的 Response 或者跳转到登录页面重新登录。所以 Cookies 和 Session 需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录会话控制。</p><h4 id="cookies结构"><a href="#cookies结构" class="headerlink" title="cookies结构"></a>cookies结构</h4><p>在浏览器开发者工具中打开 Application 选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开，可以看到类似如下内容，这些就是 Cookies，如图所示：<img src="https://i.imgur.com/Gs3dpvy.png"><br>我们可以看到 Cookies 有一个个条目，每个条目我们可以称之为 Cookie，取单数形式。它有这么几个属性：</p><ul><li>Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改<br>Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li><li>Max Age，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。Max Age 如果为正数，则该Cookie 在 Max Age 秒之后失效。如果为负数，则关闭浏览器时Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</li><li>Path，即该 Cookie 的使用路径。如果设置为 &#x2F;path&#x2F;，则只有路径为 &#x2F;path&#x2F; 的页面可以访问该 Cookie。如果设置为&#x2F;，则本域名下的所有页面都可以访问该 Cookie。</li><li>Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该Cookie。</li><li>Size字段，即此 Cookie 的大小。</li><li>Http字段，即 Cookie 的 httponly 属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie。<br>Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。<br>以上便是 Cookies 的基本结构。</li></ul><h3 id="会话cookies-和持久cookies"><a href="#会话cookies-和持久cookies" class="headerlink" title="会话cookies 和持久cookies"></a>会话cookies 和持久cookies</h3><p>表面意思来说，会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效，持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态</p><p>严格来说不可以这样定义，它只是由 Cookie 的 Max Age 或 Expires 字段决定了过期的时间，通过它浏览器可以计算出其有效时间。Max Age 如果为正数，则该 Cookie 在 Max Age 秒之后失效，如果 Max Age 特别大，那就会保存非常长的时间。如果为负数，则关闭浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><ul><li>session 随着浏览器关闭就消失了。ps:你办的会员卡会被商家主动注销吗？显然不会。</li><li>当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 Session 机制都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时也就无法找到原来的 Session。如果服务器设置的 Cookies 被保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。ps:暗示爬虫</li><li>恰恰是由于关闭浏览器不会导致 Session 被删除，这就需要服务器为 Seesion 设置一个失效时间，当距离客户端上一次使用 Session 的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把 Session 删除以节省存储空间。</li></ul><p>参考资料：-</p><ul><li><a href="http://www.mamicode.com/info-detail-46545.html" title="Session和几种状态保持方案理解">http://www.mamicode.com/info-detail-46545.html</a></li><li><a href="https://en.wikipedia.org/wiki/HTTP_cookie" title="HTTP Cookie 维基百科">https://en.wikipedia.org/wiki/HTTP_cookie</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web网页 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-HTTP基础</title>
      <link href="/2018/10/21/class0/"/>
      <url>/2018/10/21/class0/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲一下写爬虫必须大体了解的网页基础-HTTP</p><hr><p>简单的说一下写一个爬虫，我们不能盲人摸象，什么都不知道就随便的请求，即使我们熟悉那些基本库，但不了解网页还是无法完成一个真正的爬虫。主要讲解一下基本知识。</p><h2 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h2><h3 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h3><p>我们经常会听到 URI 和 URL 两个术语，URI 全称为 UniformResource Identifier，即统一资源标志符，URL 全称为 Universal Resource Locator，即统一资源定位符。例如<a href="https://github.com/favicon.ico" title="github图标">https://github.com/favicon.ico</a>，<br>我们用 URL&#x2F;URI 来唯一指定了它的访问方式。这其中包括了访问协议 https、访问路径&#x2F;即根目录，资源名称 favicon.ico，通过这样的一个链接我们便可以从互联网上找到这个资源，这就是 URL&#x2F;URI。URL是URI的子集。也就是说每个 URL 都是 URI，但不是每个 URI 都是 URL。URI 还包括一个子类叫做 URN，它的全称为 Universal Resource Name，即统一资源名称。URN 只命名资源而不指定如何定位资源，如 urn:isbn:0451450523，它指定了一本书的 ISBN，可以唯一标识这一本书，但是没有指定到哪里定位这本书，这就是 URN，URL、URN、URI 的关系可以用图 2-1 表示如下：<br><img src="https://i.imgur.com/hxDUfR4.jpg"><br>看不懂的话也，也没关系，我们只需知道URL是什么就可以了，现今几乎所有的URI也是URL.</p><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p>超文本。超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。我们可以用浏览器的开发者工具查看网页源代码，这些源代码都是超文本，如图 2-2 所示：<img src="https://i.imgur.com/YDFmQCp.png"><br>当然我们没必要看懂这些代码是做什么的，毕竟我们不是前端工程师，但是如果了解的话会更好。</p><h3 id="HTTPS-和HTTP"><a href="#HTTPS-和HTTP" class="headerlink" title="HTTPS 和HTTP"></a>HTTPS 和HTTP</h3><p>我们访问网页时会发现有的是http打头，有的却是https,有没有想过为什么，它们的区别在哪里？<br>http 或 https，这个就是访问资源需要的协议类型，有时我们还会看到 ftp、sftp、smb 开头的 URL，那么这里的 ftp、sftp、smb 都是指的协议类型。在爬虫中，我们抓取的页面通常就是 http 或 https 协议的。<br>HTTP 的全称是 Hyper Text Transfer Protocol，中文名叫做超文本传输协议，HTTP 协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证传送高效而准确地传送超文本文档。HTTP 由万维网协会（World Wide Web Consortium）和 Internet 工作小组IETF（Internet Engineering Task Force）共同合作制定的规范，目前广泛使用的是 HTTP 1.1 版本。而HTTPS则是为了安全性在HTTP下加入了SSL层，简称HTTPS。<br>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用可以分为两种：<br>1：是建立一个信息安全通道，来保证数据传输的安全。<br>2：确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。<br>随着大数据时代的发展越来越多的网站往HTTPS方向发展，为了安全。</p><p>但是有的网站即使是https协议仍然会被提示不安全，比如12306：<br><img src="https://i.imgur.com/ex8zg3E.png"><br>这是因为它的CA证书是中国铁道部自己颁发给自己的，而这个证书是不被官方机构认可的，所以这里证书验证就不会通过而提示这样的话，但是实际上它的数据传输依然是经过 SSL 加密的。我们如果要爬取这样的站点就需要设置忽略证书的选项，否则会提示 SSL链接错误。</p><h3 id="HTTP请求过程，"><a href="#HTTP请求过程，" class="headerlink" title="HTTP请求过程，"></a>HTTP请求过程，</h3><p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容，实际上这个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服务器接收到这个 Request 之后进行处理和解析，然后返回对应的一个 Response，即响应，然后传回给浏览器，Response里面就包含了页面的源代码等内容，浏览器再对其进行解析便将网页呈现了出来，我们可以利用开发者工具查看这一过程， Chrome 浏览器的开发者模式下的 Network 监听组件来做下演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。<img src="https://i.imgur.com/NVniNAP.png"><br>第一列 Name，即 Request 的名称。一般会用URL的最后一部分内容当做名称。<br>第二列 Status，即 Response 的状态码。这里显示为 200，代表 Response 是正常的，通过状态码我们可以判断发送了 Request 之后是否得到了正常的 Response。<br>第三列 Type，即 Request 请求的文档类型。这里为 document，代表我们这次请求的是一个 HTML 文档，内容就是一些 HTML 代码。<br>第四列 Initiator，即请求源。用来标记 Request 是由哪个对象或进程发起的。<br>第五列 Size，即从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源则该列会显示 from cache。<br>第六列 Time，即发起 Request 到获取到 Response 所用的总时间。<br>第七列 Timeline，即网络请求的可视化瀑布流。<br>我们点击这个条目即可看到其更详细的信息，如图 2-7 所示：<br><img src="https://i.imgur.com/dVZjUTb.png"><br>首先是 General 部分，Request URL 为 Request 的 URL，Request Method 为请求的方法，Status Code 为响应状态码，Remote Address 为远程服务器的地址和端口，Referrer Policy 为 Referrer 判别策略。<br>再继续往下看可以看到有一个 Response Headers 和一个 Request Headers，这分别代表响应头和请求头，请求头里面带有许多请求信息，例如浏览器标识、Cookies、Host 等信息，这是 Request 的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应，返回 Response，那么在图中看到的 Response Headers 就是 Response 的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到 Response 后，会解析响应内容，进而呈现网页内容。</p><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>Request，即请求，由客户端向服务端发出。可以将 Request 划分为四部分内容：Request Method、Request URL、Request Headers、Request Body，即请求方式、请求链接、请求头、请求体。</p><h5 id="Request-Method"><a href="#Request-Method" class="headerlink" title="Request Method"></a>Request Method</h5><p>请求方式，请求方式常见的有两种类型，GET 和 POST。<br>我们在浏览器中直接输入一个 URL 并回车，这便发起了一个 GET 请求，请求的参数会直接包含到 URL 里，例如百度搜索 Python，这就是一个 GET 请求，链接为：<a href="https://www.baidu.com/s?wd=Python%EF%BC%8CURL">https://www.baidu.com/s?wd=Python，URL</a> 中包含了请求的参数信息，这里参数 wd 就是要搜寻的关键字。POST 请求大多为表单提交发起，如一个登录表单，输入用户名密码，点击登录按钮，这通常会发起一个 POST 请求，其数据通常以 Form Data 即表单的形式传输，不会体现在 URL 中。<br>GET 和 POST 请求方法有如下区别：<br>GET 方式请求中参数是包含在 URL 里面的，数据可以在 URL 中看到，而 POST 请求的 URL 不会包含这些数据，数据都是通过表单的形式传输，会包含在 Request Body 中。<br>GET 方式请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。<br>所以一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用GET方式请求的话密码就会暴露在URL里面，造成密码泄露，所以这里最好以POST方式发送。文件的上传时，由于文件内容比较大，也会选用POST方式。</p><p>我们平常遇到的绝大部分请求都是 GET 或 POST 请求，另外还有一些请求方式，如 HEAD、PUT、DELETE、OPTIONS、CONNECT、TRACE，我们简单将其总结如下：<br><img src="https://i.imgur.com/qBBbTZV.png"></p><h4 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h4><p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等，下面将一些常用的头信息说明如下：<br>Accept，请求报头域，用于指定客户端可接受哪些类型的信息。<br>Accept-Language，指定客户端可接受的语言类型。<br>Accept-Encoding，指定客户端可接受的内容编码。<br>Host，用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。<br>Cookie，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在用户本地的数据。Cookies 的主要功能就是维持当前访问会话，例如我们输入用户名密码登录了某个网站，登录成功之后服务器会用 Session 保存我们的登录状态信息，后面我们每次刷新或请求该站点的其他页面时会发现都是保持着登录状态的，在这里就是 Cookies 的功劳，Cookies 里有信息标识了我们所对应的服务器的 Session 会话，每次浏览器在请求该站点的页面时都会在请求头中加上 Cookies 并将其发送给服务器，服务器通过 Cookies 识别出是我们自己，并且查出当前状态是登录的状态，所以返回的结果就是登录之后才能看到的网页内容。<br>Referer，此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、做防盗链处理等。<br>User-Agent，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息可以伪装为浏览器，如果不加很可能会被识别出为爬虫。<br>Content-Type，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头中，使用它来表示具体请求中的媒体类型信息。例如 text&#x2F;html 代表 HTML 格式，image&#x2F;gif 代表 GIF 图片，application&#x2F;json 代表 Json 类型，更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons%E3%80%82">http://tool.oschina.net/commons。</a><br>因此，Request Headers 是 Request 等重要组成部分，在写爬虫的时候大部分情况都需要设定 Request Headers。<br>还有Requests Body这里不赘述，一般承载的内容是 POST 请求中的 Form Data，即表单数据，而对于 GET 请求 Request Body 则为空。</p><h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404 则代表页面未找到，500 则代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如判断状态码为 200，则证明成功返回数据，再进行进一步的处理，否则直接忽略。<br>其他还有一些常见的比如：<br>404：服务器找不到请求的网页。<br>504：网关超时<br>其他的自行查找吧。</p><h4 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h4><p>响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等，下面将一些常用的头信息说明如下：<br>Date，标识 Response 产生的时间。<br>Last-Modified，指定资源的最后修改时间。<br>Content-Encoding，指定 Response 内容的编码。<br>Server，包含了服务器的信息，名称，版本号等。<br>Content-Type，文档类型，指定了返回的数据类型是什么，如text&#x2F;html 则代表返回 HTML 文档，application&#x2F;x-javascript 则代表返回 JavaScript 文件，image&#x2F;jpeg 则代表返回了图片。<br>Set-Cookie，设置Cookie，Response Headers 中的 Set-Cookie即告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。<br>Expires，指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更新到缓存中，如果再次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。</p><h4 id="Resposne-Body"><a href="#Resposne-Body" class="headerlink" title="Resposne Body"></a>Resposne Body</h4><p>即响应体，最重要的当属响应体内容了，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的 HTML 代码，请求一张图片，它的响应体就是图片的二进制数据。所以最主要的数据都包含在响应体中了，我们做爬虫请求网页后要解析的内容就是解析响应体，如图 2-9 所示<img src="https://i.imgur.com/f9qesBu.png"><br>我们在浏览器开发者工具中点击 Preview，就可以看到网页的源代码，这也就是响应体内容，是解析的目标。<br>我们在做爬虫时主要解析的内容就是 Resposne Body，通过 Resposne Body 我们可以得到网页的源代码、Json 数据等等，然后从中做相应内容的提取。</p><p>以上便是 Response 的组成部分。我们了解了 HTTP 的基本原理，通过如上描述，我们应该对访问网页背后的请求和响应过程有了大体的认识，本节涉及到的知识点需要好好掌握，在后面分析网页请求的时候会经常用到。</p><h2 id="代理ip"><a href="#代理ip" class="headerlink" title="代理ip"></a>代理ip</h2><h3 id="为什么要用代理ip"><a href="#为什么要用代理ip" class="headerlink" title="为什么要用代理ip"></a>为什么要用代理ip</h3><p>有时候你会发现自己辛辛苦苦写好的爬虫程序正在运行，正当自己心底沾沾自喜的时候，突然报错，抓取不到网页了！这是为什么呢，自己程序也没错误啊！ 打开网页一看发现提示自己的ip被封了，说我们的访问频率太高了，因此把我们的ip封禁了，这也是常见的反爬虫措施之一。</p><p>为什么要封禁我们的ip呢，因为我们的爬虫多次对这个网页请求，加大了服务器的负担，为了不影响正常用户的使用，也为了不让自己辛辛苦苦的数据被你无情的拿走，直接禁止你访问这个网页。</p><p>一般是单位时间内设置一个阈值，如果超过这个访问频率，那么直接say goodbye.那么我们甘心被它无情的封禁吗？显然不可能，既然你根据单位时间内的阈值判断是否为爬虫，那么我可以设置缓冲时间来间歇访问，但这样显然会拖慢我们的时间，还是更换代理ip进行访问比较方便，你封了一个我就换个ip继续访问。</p><h3 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h3><p>我们常称呼的代理实际上指的就是代理服务器，英文叫做 Proxy Server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了 Request 给 Web 服务器，Web 服务器把 Response 传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向 Web 服务器发起请求，而是向代理服务器发出请求， Request 会发送给代理服务器，然后由代理服务器再发送给 Web 服务器，然后由代理服务器再把 Web 服务器返回的 Response 转发给本机，这样我们同样可以正常访问网页，但这个过程 Web 服务器识别出的真实的 IP 就不再是我们本机的 IP 了，就成功实现了 IP 伪装，这就是代理的基本原理。 通俗的讲就是找了一个不收差价的中间商，我们不直接对话，通过这个中间商进行沟通。</p><h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><p>我们可以简单列举如下：</p><ul><li>突破自身 IP 访问限制，访问一些平时不能访问的站点。比如：YouTube，推特………..</li><li>访问一些单位或团体内部资源，如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类 FTP 下载上传，以及各类资料查询共享等服务。 比如我们学校的内网，在某些时候是不对外界开放的，只能通过校园网进行访问。</li><li>提高访问速度，通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实 IP，上网者也可以通过这种方法隐藏自己的 IP，免受攻击，对于爬虫来说，我们用代理就是为了隐藏自身 IP，防止自身的 IP 被封锁。黑客也一般会使用很多代理，尽力隐藏自己的真实地址（为了人身安全）。</li></ul><h3 id="代理的类别"><a href="#代理的类别" class="headerlink" title="代理的类别"></a>代理的类别</h3><h4 id="匿名性分类"><a href="#匿名性分类" class="headerlink" title="匿名性分类"></a>匿名性分类</h4><p>列举如下：</p><ul><li>高度匿名代理，高度匿名代理会将数据包原封不动的转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的 IP 是代理服务器的 IP。</li><li>普通匿名代理，普通匿名代理会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 IP。代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR。</li><li>透明代理，透明代理不但改动了数据包，还会告诉服务器客户端的真实 IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li>间谍代理，间谍代理指组织或个人创建的，用于记录用户传输的数据，然后进行研究、监控等目的代理服务器。</li></ul><h4 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h4><ul><li>FTP 代理服务器，主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121 等。</li><li>HTTP 代理服务器，主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128 等。</li><li>SSL&#x2F;TLS 代理，主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位加密强度），端口一般为 443。</li><li>RTSP 代理，主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554。</li><li>Telnet代理，主要用于 telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为23。</li><li>POP3&#x2F;SMTP 代理，主要用于 POP3&#x2F;SMTP 方式收发邮件，一般有缓存功能，端口一般为 110&#x2F;25。</li><li>SOCKS代理，只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 协议只支持 TCP，而 SOCKS5 协议支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说，SOCK4能做到的SOCKS5都可以做到，但SOCKS5能做到的SOCK4不一定能做到。</li></ul><p>我们可以常见的有这些：</p><ul><li>网上的免费代理，最好使用高匿代理，使用前抓取下来筛选一下可用代理，也可以进一步维护一个代理池。</li><li>付费代理服务，互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。<br>ADSL拨号，拨一次号换一次 IP，稳定性高，也是一种比较有效的解决方案。</li></ul><p>参考自 ：<a href="https://germey.gitbooks.io/python3webspider/">https://germey.gitbooks.io/python3webspider/</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" title="代理服务器">https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐评论</title>
      <link href="/2018/10/18/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/"/>
      <url>/2018/10/18/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本文是为了爬取遍地情圣的网易评论区</p><h2 id="用到的知识"><a href="#用到的知识" class="headerlink" title="用到的知识"></a>用到的知识</h2><p>主要有:requestes,beautifulsoup,PyCryptodome等。<br>###加密的网页<br>首先我们随机点开一首歌，用requests.get()获取其源码，结果我们发现好多信息是经过加密的，我们不能提取到有效的信息，贴个代码演示一下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/song?id=<span class="variable">$&#123;x.id&#125;</span>&quot;</span>&gt;&lt;b title=<span class="string">&quot;<span class="variable">$&#123;x.name|escape&#125;</span>&#123;if alia&#125; - (<span class="variable">$&#123;alia|escape&#125;</span>)&#123;/if&#125;&quot;</span>&gt;<span class="variable">$&#123;soil(x.name)&#125;</span>&lt;/b&gt;&lt;/a&gt;&#123;<span class="keyword">if</span> alia&#125;&lt;span title=<span class="string">&quot;<span class="variable">$&#123;alia|escape&#125;</span>&quot;</span> class=<span class="string">&quot;s-fc8&quot;</span>&gt; - (<span class="variable">$&#123;soil(alia)&#125;</span>)&lt;/span&gt;&#123;/if&#125;</span><br><span class="line">&#123;<span class="keyword">if</span> x.mvid&gt;0&#125;</span><br><span class="line">&lt;span data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span> data-res-action=<span class="string">&quot;mv&quot;</span> title=<span class="string">&quot;播放mv&quot;</span> class=<span class="string">&quot;mv&quot;</span>&gt;MV&lt;/span&gt;</span><br><span class="line">&#123;/if&#125;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;opt hshow&quot;</span>&gt;</span><br><span class="line">&lt;a class=<span class="string">&quot;u-icn u-icn-81 icn-add&quot;</span> href=<span class="string">&quot;javascript:;&quot;</span> title=<span class="string">&quot;添加到播放列表&quot;</span> hidefocus=<span class="string">&quot;true&quot;</span></span><br><span class="line">data-res-type=<span class="string">&quot;18&quot;</span></span><br><span class="line">data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span></span><br><span class="line">data-res-action=<span class="string">&quot;addto&quot;</span></span><br><span class="line">&#123;<span class="keyword">if</span> from&#125;data-res-from=<span class="string">&quot;<span class="variable">$&#123;from.fid&#125;</span>&quot;</span> data-res-data=<span class="string">&quot;<span class="variable">$&#123;from.fdata&#125;</span>&quot;</span>&#123;/if&#125;&gt;&lt;/a&gt;</span><br><span class="line">&lt;span data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span> data-res-type=<span class="string">&quot;18&quot;</span> data-res-action=<span class="string">&quot;fav&quot;</span> class=<span class="string">&quot;icn icn-fav&quot;</span> title=<span class="string">&quot;收藏&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span> data-res-type=<span class="string">&quot;18&quot;</span> data-res-action=<span class="string">&quot;share&quot;</span> data-res-name=<span class="string">&quot;<span class="variable">$&#123;x.name&#125;</span>&quot;</span> data-res-author=<span class="string">&quot;&#123;list x.artists as art&#125;<span class="variable">$&#123;art.name&#125;</span>&#123;if art_index&lt;x.artists.length-1&#125;/&#123;/if&#125;&#123;/list&#125;&quot;</span> &#123;<span class="keyword">if</span> x.album&#125;data-res-pic=<span class="string">&quot;<span class="variable">$&#123;x.album.picUrl&#125;</span>&quot;</span>&#123;/if&#125; class=<span class="string">&quot;icn icn-share&quot;</span> title=<span class="string">&quot;分享&quot;</span>&gt;分享&lt;/span&gt;</span><br><span class="line">&lt;span data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span> data-res-type=<span class="string">&quot;18&quot;</span> data-res-action=<span class="string">&quot;download&quot;</span> class=<span class="string">&quot;icn icn-dl&quot;</span> title=<span class="string">&quot;下载&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&#123;<span class="keyword">if</span> canDel&#125;</span><br><span class="line">&lt;span data-res-id=<span class="string">&quot;<span class="variable">$&#123;x.id&#125;</span>&quot;</span> data-res-type=<span class="string">&quot;18&quot;</span> data-res-action=<span class="string">&quot;delete&quot;</span> class=<span class="string">&quot;icn icn-del&quot;</span> title=<span class="string">&quot;删除&quot;</span>&gt;删除&lt;/span&gt;</span><br><span class="line">&#123;/if&#125;</span><br></pre></td></tr></table></figure><p>我们可以清楚的看到，我们需要提取的信息都被加密过。无法通过普通的办法获得我们想要的内容。</p><h4 id="两种思路"><a href="#两种思路" class="headerlink" title="两种思路"></a>两种思路</h4><p>这时我们有两种思路：<br>1：使用selenium模拟浏览器的操作进行爬取。此方法我们不在这篇文章里讲述，想尝试的同学可以自己尝试。<br>2：鉴于该数据采取ajax，我们通过访问该网址获取其json字符串，直接完成其信息的采集。我们先按思路二进行下去。</p><h3 id="获取第一页数据"><a href="#获取第一页数据" class="headerlink" title="获取第一页数据"></a>获取第一页数据</h3><p>首先在加载的一堆数据中排查得到我们需要的网址，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request URL: https://music.163.com/weapi/v1/resource/comments/R_SO_4_531295576?csrf_token=</span><br><span class="line">Request Method: POST</span><br><span class="line">Status Code: 200 OK</span><br><span class="line">Remote Address: 127.0.0.1:1080</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 482</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Cookie: 过长就不贴了。</span><br><span class="line">Host: music.163.com</span><br><span class="line">Origin: https://music.163.com</span><br><span class="line">Referer: https://music.163.com/song?<span class="built_in">id</span>=531295576</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36</span><br><span class="line"></span><br><span class="line">Form Ddta:</span><br><span class="line">params: +0YydG970lh0RFa4CtT3YQEDyAB+YtGNJ+UbomdqEnY+TemTKHVbA3vJIX3NKgm07UOy+J2sKcSTM0smfpKbOA4Dm8TJcxbWZrVnjeVl/zE3z3PX21iD84D5Qt50oLrZv8Gug+LqS/y1JWBWiq6DZ0ZaZZEG8aYRYF2bwnPxX9v55DxZJmiubjteCc5lMs0S</span><br><span class="line">encSecKey: 762617ad7682a61121e378406d57ffd5aede0f3621e18d1584dab1eca7fdf3ca3d842d882111609a4ada5d3c24973450d1a8553ff96641f144a6de81688ae2c0a5798f8c23fa38e16139999692b6c91150b39c25c014ee6a2005e821485c3a6eab822db16f0397be0c54e43993cc34eae70c68739d19d0eb69e7ca86b16b585a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看出他是一个post请求，通过多次测试我们发现网址中那个数字会有变化。其他则保持不变，这串数字也很简单的可以发现就是这首歌在网易云的id，我们需要先爬取这个id之后才能进行下一步的操作(以热歌榜为例）。上代码说话。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ConnectionError</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url,headers = headers,timeout = <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            response.encoding = <span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>,response.status_code)</span><br><span class="line">    <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>,e.args)</span><br><span class="line">    <span class="keyword">except</span> Timeout <span class="keyword">as</span> t:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>,t.args)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_url</span>(<span class="params">html</span>):</span><br><span class="line">    hot_list = re.findall(<span class="string">r&#x27;&lt;ul class=&quot;f-hide&quot;&gt;&lt;li&gt;&lt;a href=&quot;/song\?id=\d*?&quot;&gt;.*&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#x27;</span>,html)</span><br><span class="line">    hot_list = hot_list[<span class="number">0</span>]</span><br><span class="line">    hot_music_id = re.findall(<span class="string">r&#x27;&lt;li&gt;&lt;a href=&quot;/song\?id=(\d*?)&quot;&gt;.*?&lt;/a&gt;&lt;/li&gt;&#x27;</span>,hot_list)</span><br><span class="line">    hot_music_name = re.findall(<span class="string">r&#x27;&lt;li&gt;&lt;a href=&quot;/song\?id=\d*?&quot;&gt;(.*?)&lt;/a&gt;&lt;/li&gt;&#x27;</span>,hot_list)</span><br><span class="line">    <span class="keyword">return</span> hot_music_name,hot_music_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url = <span class="string">&quot;https://music.163.com/discover/toplist?id=3778678&quot;</span></span><br><span class="line">    html = get_index(url)</span><br><span class="line">    <span class="keyword">if</span> html:</span><br><span class="line">        hot_music_name,hot_music_id = parse_url(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我用正则表达式提取出其id和名字，既然id到了那么下面应该很简单的吧。答案是这样吗？我们继续看：</p><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p>请求数据里有两个参数，params 和 encSecKey。如果我们只爬取该歌曲的第一页评论（或者说热评）的话，那么我们只要把这两个参数复制然后构造post请求，可以简单的做到这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    data =&#123;</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: <span class="string">&quot;dPn4YKam1ALLghjJadhyim4G05a1atAbF7ECvh5EGXihbxOV1i+TRS2oNZv+jR8H6nZ0DSoff6PQQ9mEnocZIv8D5ispn9aLDlta+vylq2wUnJQYLR0KkoQFYcXQ+VOvbmJyLK1acsZ/GuCkP+XFbr3h9WtEAXu3sxfn0DKFO06eNMufFrUHTmw7zyVFp64zYAHK4jIvkSTAkkVYqMu2IbwYG4coJ6wScE1DwKyRQlE=&quot;</span>,</span><br><span class="line">        <span class="string">&quot;encSecKey&quot;</span>: <span class="string">&quot;ca034db233499f555cd0009cf367f35093381ded33765fb6026c09c333a20b41d87bcd71504fc87159d55f6b2308343b0d443b8c68c575c1b6e6c37c98fdb571e4a0f61beb292ba4847840ba52f4d0f1c3169e3a2492c00a2cc7b4664a5eb63c6c06be9d90b9a0dc0c305aa8204820225ab5aeace9c2d4ee0dd628a5a022cdba&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = BASE_URL + <span class="built_in">id</span> + <span class="string">&quot;?csrf_token=&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(url,headers=headers,data=data)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>,e.args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_parse</span>(<span class="params">name,data</span>):</span><br><span class="line">    data = data[<span class="string">&#x27;hotComments&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;Comments&quot;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&quot;Comments&quot;</span>)</span><br><span class="line">    file_path = <span class="string">&quot;&#123;&#125;/Hot.txt&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Comments&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(name + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> contents <span class="keyword">in</span> data:</span><br><span class="line">            f.write(<span class="built_in">str</span>(num) +<span class="string">&quot;:&quot;</span>+ contents[<span class="string">&#x27;content&#x27;</span>] + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;***************************************************&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Success&quot;</span>,name)</span><br></pre></td></tr></table></figure><p>但是我们仅仅满足于热评吗？？？网易云的情圣们可能还隐藏在里面，那么我们继续采坑吧。</p><h3 id="破译加密算法"><a href="#破译加密算法" class="headerlink" title="破译加密算法"></a>破译加密算法</h3><p>我们点击评论的下一页，通过开发者工具我们可以发现网址丝毫不变，其他也基本不变，那么我们的数据是怎么改变的呢，post传输的数据为罪魁祸首，那么这些post数据是怎么变化的呢，通过不断地寻找我们锁定了一个js脚本，我们发现这串数据来自于它，并且是加密过的（好难受），加密函数如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="keyword">function</span> a(a) &#123;</span><br><span class="line">        var d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (d = 0; a &gt; d; d += 1)</span><br><span class="line">            e = Math.random() * b.length,</span><br><span class="line">            e = Math.floor(e),</span><br><span class="line">            c += b.charAt(e);</span><br><span class="line">        <span class="built_in">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> b(a, b) &#123;</span><br><span class="line">        var c = CryptoJS.enc.Utf8.parse(b)</span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(<span class="string">&quot;0102030405060708&quot;</span>)</span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)</span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;</span><br><span class="line">            iv: d,</span><br><span class="line">            mode: CryptoJS.mode.CBC</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">return</span> f.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> c(a, b, c) &#123;</span><br><span class="line">        var d, e;</span><br><span class="line">        <span class="built_in">return</span> setMaxDigits(131),</span><br><span class="line">        d = new RSAKeyPair(b,<span class="string">&quot;&quot;</span>,c),</span><br><span class="line">        e = encryptedString(d, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> d(d, e, f, g) &#123;</span><br><span class="line">        var h = &#123;&#125;</span><br><span class="line">          , i = a(16);</span><br><span class="line">        <span class="built_in">return</span> h.encText = b(d, g),</span><br><span class="line">        h.encText = b(h.encText, i),</span><br><span class="line">        h.encSecKey = c(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> e(a, b, d, e) &#123;</span><br><span class="line">        var f = &#123;&#125;;</span><br><span class="line">        <span class="built_in">return</span> f.encText = c(a + e, b, d),</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line">    window.asrsea = d,</span><br><span class="line">    window.ecnonasr = e</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">window.asrsea函数就是那个加密的罪魁祸首。也就是上面的d函数.</span><br></pre></td></tr></table></figure><p>可以看出它采用CryptoJS加密,我们可以通过PyCryptodome(python3用户），如果你是python2的话，请安装这个pycrypto，pycrypto已经宣布永久停止维护了，所以请移步PyCryptodome吧，<a href="https://github.com/Legrandin/pycryptodome" title="PyCryptodome的github地址">https://github.com/Legrandin/pycryptodome</a>。</p><p>那么我们是如何发现这个函数的呢，Chrome开发者控制面板–source–点击 Event Listener Breakpoints–勾选XHR–点击重新加载–然后点击 Step over next function call的那个图标，就这样单步调试过去，就能找到那个函数。。然后我们打开Chrome的调试工具，把断点设在12973行我们可以发现上面的参数（格式化js语句点击下面出现的{}标志即可），既然找到了加密函数和相应的参数，那么我们开始用py模仿破解吧，经过多次翻页我们发现只有<br>{rid: “R_SO_4_574566207”, offset: “40”, total: “false”, limit: “20”, csrf_token: “”}<br>{rid: “R_SO_4_574566207”, offset: “60”, total: “false”, limit: “20”, csrf_token: “”}<br>可以看出只有offset参数是变化的，limit参数经过分析是控制每页评论数的，限制每页20条，其他则是固定不变的，结合上面的window.asrsea()函数，我们构造出加密字符串，完成post请求进而得到我们的评论数据。</p><h4 id="python构造加密"><a href="#python构造加密" class="headerlink" title="python构造加密"></a>python构造加密</h4><p>回到我们的加密函数上，我们发现它经过AES加密和RSA加密。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> d(d, e, f, g) &#123;</span><br><span class="line">        var h = &#123;&#125;</span><br><span class="line">          , i = a(16);</span><br><span class="line">        <span class="built_in">return</span> h.encText = b(d, g), <span class="comment">#AES加密</span></span><br><span class="line">        h.encText = b(h.encText, i), <span class="comment">#AES加密</span></span><br><span class="line">        h.encSecKey = c(i, e, f), <span class="comment">#RSA加密</span></span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不懂这些加密函数什么意思，自学啊，还是先模仿吧。用到我们上面写到的PyCryptodome库，进行Crypto加密。我还是贴代码吧。。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入这些第三方库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br></pre></td></tr></table></figure><p>首先我们需要生成长度为16的随机字符串,这里我们仿照上面的javascript的实现,用Python生成16位长的随机字符串:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def generate_random_strs(length):</span><br><span class="line">    string = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span></span><br><span class="line">    <span class="comment"># 控制次数参数i</span></span><br><span class="line">    i = 0</span><br><span class="line">    <span class="comment"># 初始化随机字符串</span></span><br><span class="line">    random_strs  = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; length:</span><br><span class="line">        e = random.random() * len(string)</span><br><span class="line">        <span class="comment"># 向下取整</span></span><br><span class="line">        e = math.floor(e)</span><br><span class="line">        random_strs = random_strs + list(string)[e]</span><br><span class="line">        i = i + 1</span><br><span class="line">    <span class="built_in">return</span> random_strs</span><br></pre></td></tr></table></figure><p>AES加密的模式是AES.MODE_CBC,初始化向量iv&#x3D;’0102030405060708′,具体的AES加密</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AES加密</span></span><br><span class="line">def AESencrypt(msg, key):</span><br><span class="line">    <span class="comment"># 如果不是16的倍数则进行填充(paddiing)</span></span><br><span class="line">    padding = 16 - len(msg) % 16</span><br><span class="line">    <span class="comment"># 这里使用padding对应的单字符进行填充</span></span><br><span class="line">    msg = msg + padding * chr(padding)</span><br><span class="line">    <span class="comment"># 用来加密或者解密的初始向量(必须是16位)</span></span><br><span class="line">    iv = <span class="string">&#x27;0102030405060708&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    <span class="comment"># 加密后得到的是bytes类型的数据</span></span><br><span class="line">    encryptedbytes = cipher.encrypt(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># 使用Base64进行编码,返回byte字符串</span></span><br><span class="line">    encodestrs = base64.b64encode(encryptedbytes)</span><br><span class="line">    <span class="comment"># 对byte字符串按utf-8进行解码</span></span><br><span class="line">    enctext = encodestrs.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> enctext</span><br></pre></td></tr></table></figure><p>RSA加密.首先我简单介绍一下RSA的加密过程.在RSA中,明文,密钥和密文都是数字.RSA的加密过程可以用下列的公式来表达,这个公式非常的重要,你只有理解了这个公式,才能用Python实现RSA加密</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">密文    =    明文^E mod  N           (RSA加密)</span><br></pre></td></tr></table></figure><p>RSA的密文是对代表明文的数字的E次方求mod N 的结果, 通俗的讲就是将明文和自己做E次乘法,然后将其结果除以N 求余数,这个余数就是密文.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RSA加密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RSAencrypt</span>(<span class="params">randomstrs, key, f</span>):</span><br><span class="line">    <span class="comment"># 随机字符串逆序排列</span></span><br><span class="line">    string = randomstrs[::-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 将随机字符串转换成byte类型数据</span></span><br><span class="line">    text = <span class="built_in">bytes</span>(string, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    seckey = <span class="built_in">int</span>(codecs.encode(text, encoding=<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)**<span class="built_in">int</span>(key, <span class="number">16</span>) % <span class="built_in">int</span>(f, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">format</span>(seckey, <span class="string">&#x27;x&#x27;</span>).zfill(<span class="number">256</span>)</span><br></pre></td></tr></table></figure><p>RSA加密后得到的字符串长为256,如果不够长则进行填充(不足部分在左侧添0).然后就是获取那两个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="comment"># msg也可以写成msg = &#123;&quot;offset&quot;:&quot;页面偏移量=(页数-1) *　20&quot;, &quot;limit&quot;:&quot;20&quot;&#125;,offset和limit这两个参数必须有(js)</span></span><br><span class="line">    <span class="comment"># limit最大值为100,当设为100时,获取第二页时,默认前一页是20个评论,也就是说第二页最新评论有80个,有20个是第一页显示的</span></span><br><span class="line">    <span class="comment"># msg = &#x27;&#123;&quot;rid&quot;:&quot;R_SO_4_1302938992&quot;,&quot;offset&quot;:&quot;0&quot;,&quot;total&quot;:&quot;True&quot;,&quot;limit&quot;:&quot;100&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment"># 偏移量</span></span><br><span class="line">    offset = (page-<span class="number">1</span>) * <span class="number">20</span></span><br><span class="line">    <span class="comment"># offset和limit是必选参数,其他参数是可选的,其他参数不影响data数据的生成</span></span><br><span class="line">    msg = <span class="string">&#x27;&#123;&quot;offset&quot;:&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="string">&#x27;,&quot;total&quot;:&quot;True&quot;,&quot;limit&quot;:&quot;20&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span></span><br><span class="line">    key = <span class="string">&#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line">    f = <span class="string">&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;</span></span><br><span class="line">    e = <span class="string">&#x27;010001&#x27;</span></span><br><span class="line">    enctext = AESencrypt(msg, key)</span><br><span class="line">    <span class="comment"># 生成长度为16的随机字符串</span></span><br><span class="line">    i = generate_random_strs(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 两次AES加密之后得到params的值</span></span><br><span class="line">    encText = AESencrypt(enctext, i)</span><br><span class="line">    <span class="comment"># RSA加密之后得到encSecKey的值</span></span><br><span class="line">    encSecKey = RSAencrypt(i, e, f)</span><br><span class="line">    <span class="keyword">return</span> encText, encSecKey</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面构造表单不再赘述，所有参数都已得到。如果想用selenium的大佬，可以自己尝试一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻算法</title>
      <link href="/2018/10/13/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/13/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文是根据机器学习实战那本书学习的部分总结</p><h2 id="k近邻算法简介"><a href="#k近邻算法简介" class="headerlink" title="k近邻算法简介"></a>k近邻算法简介</h2><p>简单的来说就是根据测量不同特征值之间的距离进而对数据集进行分类。</p><p>该算是原理是根据我们已知的特征值对应关系，对我们想要分类的新数据进行判断分类。比如我们想判断一个电影的题材那么我们就可以提取一定的特征值，电影中惊悚片段的次数等等，然后用该算法构造程序，自动化分。<br>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p><h3 id="k近邻算法的流程"><a href="#k近邻算法的流程" class="headerlink" title="k近邻算法的流程"></a>k近邻算法的流程</h3><p>1收集数据：爬虫或者一些已存在的数据集<br>2准备数据：结构化数据格式<br>3分析数据：可用任何方法<br>4训练算法：（不适用于k近邻）<br>5测试算法：计算成功率<br>6使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输<br>入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理</p><h4 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h4><p>请看代码：<br>1：导入数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">group = array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3.1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">labels = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>]</span><br><span class="line"><span class="keyword">return</span> group,labels</span><br></pre></td></tr></table></figure><p>定义一个标准数据集（每组包含两个数据）和标签，一一对应。我们将[1,1]定义为类A,依次类推。</p><hr><h4 id="进行距离运算，预测类型"><a href="#进行距离运算，预测类型" class="headerlink" title="进行距离运算，预测类型"></a>进行距离运算，预测类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classify0</span>(<span class="params">inX, dataSet,labels,k</span>):</span><br><span class="line">dataSetsize = dataSet.shape[<span class="number">0</span>]  <span class="comment">#计算训练数据集的行数</span></span><br><span class="line">diffMat = tile(inX,(dataSetsize,<span class="number">1</span>) - dataSet)  </span><br><span class="line">sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">sqDistance = sqDiffMat.<span class="built_in">sum</span>(axis)  <span class="comment">#将一轴上的数据相加</span></span><br><span class="line">distance = sqDistance**<span class="number">0.5</span></span><br><span class="line">sorteDistIndicies = distance.argsort() <span class="comment">#返回distances中元素从小到大排序后的索引值</span></span><br><span class="line">classCount = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">voteIlable = labels[sorteDistIndicies[i]]</span><br><span class="line">classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">sortedClassCount = <span class="built_in">sorted</span>(classCount.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>) <span class="comment">#key=operator.itemgetter(1)根据字典的值进行排序，reverse = True 以降序排列</span></span><br><span class="line"><span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这样我们就可以返回次数出现最高的标签进而输出预测值，但是我们无法判断这个分类是否正确，因此我们需要测试一下。</p><hr><h2 id="海伦约会-栗子"><a href="#海伦约会-栗子" class="headerlink" title="海伦约会-栗子"></a>海伦约会-栗子</h2><p>她把这些数据存放在文本文件datingTestSet.txt中<br>海伦的样本主要包含以下3种特征：<br> 每年获得的飞行常客里程数<br> 玩视频游戏所耗时间百分比<br> 每周消费的冰淇淋公升数<br>首先py读取收集到的txt文件数据，使其可以被使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file2matrix</span>(<span class="params">filename</span>):</span><br><span class="line">fr = <span class="built_in">open</span>(filename)</span><br><span class="line">arrayoLine = fr.readlines()</span><br><span class="line">numberoflines = <span class="built_in">len</span>(arrayoLine)</span><br><span class="line">returnMat = zeros((numberoflines,<span class="number">3</span>))</span><br><span class="line">classLabelVectors = []</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> arrayoLine:</span><br><span class="line">line = line.strip() <span class="comment">#去除空白</span></span><br><span class="line">listFormLine = line.split(<span class="string">&#x27;\t&#x27;</span>) <span class="comment">#以制表符为标志切片</span></span><br><span class="line">returnMat[index,:] = listFormLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> listFromLine[-<span class="number">1</span>] == <span class="string">&#x27;didntLike&#x27;</span>:</span><br><span class="line">            classLabelVector.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> listFromLine[-<span class="number">1</span>] == <span class="string">&#x27;smallDoses&#x27;</span>:</span><br><span class="line">            classLabelVector.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> listFromLine[-<span class="number">1</span>] == <span class="string">&#x27;largeDoses&#x27;</span>:</span><br><span class="line">            classLabelVector.append(<span class="number">3</span>)</span><br><span class="line">        index+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br></pre></td></tr></table></figure><hr><h3 id="图形化展示"><a href="#图形化展示" class="headerlink" title="图形化展示"></a>图形化展示</h3><p>返回读取成功的数据集，和标签集合集合。先进行图形化分析一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig = plt.figure() <span class="comment">#创建一个画布</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.scatter(datingDataMat[:,<span class="number">1</span>],datingDataMat[:,<span class="number">2</span>],<span class="number">15.0</span>*array(datingLabels),<span class="number">15.0</span>*array[datingLabels]) <span class="comment">#以特征值一和二为数据画图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图略，我们发现一些数字值相差太大影响我们的结果，因此我们进行归一化数值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autoNorm</span>(<span class="params">dataSet</span>):</span><br><span class="line">minVals = dataSet.<span class="built_in">min</span>(<span class="number">0</span>) <span class="comment">#min()中0对应列，1对应行。不输入测全部数据的最小值</span></span><br><span class="line">maxVals = dataSet.<span class="built_in">max</span>(<span class="number">0</span>) </span><br><span class="line">ranges = maxVals - minVals</span><br><span class="line">normDataSet = zeros(shape(dataSet))</span><br><span class="line">m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">normDataSet = dataSet - tile(minVals,(m,<span class="number">1</span>))</span><br><span class="line">normDataSet = normDataSet/(tile(ranges,(m,<span class="number">1</span>)))</span><br><span class="line"><span class="keyword">return</span> normDataSet,ranges,minVals</span><br></pre></td></tr></table></figure><p>将最大的数值当作1，最小的当作0，其他等比例压缩。<br>通常我们只提供已有数据的90%作为训练样本来训练分类<br>器，而使用其余的10%数据去测试分类器，检测分类器的正确率。本书后续章节还会介绍一些高级方法完成同样的任务，这里我们还是采用最原始的做法。需要注意的是，10%的测试数据应该是随机选择的，由于海伦提供的数据并没有按照特定目的来排序，所以我们可随意选择10%数据而不影响其随机性。</p><hr><h3 id="计算错误率"><a href="#计算错误率" class="headerlink" title="计算错误率"></a>计算错误率</h3><p>代码里我们定义一个计数器变量，每次分类器错误地分类数据，计数器就加1，程序执行完成之后计数器的结果除以数据点总数即是错误率<br>进入正题测试预测结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">datingClassTest</span>():</span><br><span class="line">horatio = <span class="number">0.10</span></span><br><span class="line">datingDataMat,datingLabels = file2matrix(<span class="string">&#x27;datingTestSet,txt&#x27;</span>)</span><br><span class="line">normMat,ranges,minVals = autoNorm(datingDataMat)</span><br><span class="line">m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">numTestVecs = <span class="built_in">int</span>(m*horatio)</span><br><span class="line">errCount = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTestVecs):</span><br><span class="line">classifreResult = classify0(normMat[i,:],normMat[numTestVecs,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类结果:%s\t真实类别:%d&quot;</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">        <span class="keyword">if</span> classifierResult != datingLabels[i]:</span><br><span class="line">            errorCount += <span class="number">1.0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误率:%f%%&quot;</span> % (errorCount / <span class="built_in">float</span>(numTestVecs) * <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>一个简单的分类系统就做好了，我们需要优化一下。让海伦找到自己理想的伴侣</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calssifyPerson</span>():</span><br><span class="line">resultList=[<span class="string">&#x27;not at all&#x27;</span>,<span class="string">&#x27;in small doses&#x27;</span>,<span class="string">&#x27;in large doses&#x27;</span>]</span><br><span class="line">    percentTats=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;percentage of time spent playing video games?&quot;</span>))</span><br><span class="line">    ffMiles=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;frequent flier miles earned per year?&quot;</span>))</span><br><span class="line">    iceCream=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;liters of ice cream consumed per year?&quot;</span>))</span><br><span class="line">    datingDataMat,datingLabels=file2matrix(<span class="string">&#x27;datingTestSet2.txt&#x27;</span>)<span class="comment">#原书没有2</span></span><br><span class="line">    normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">    inArr=array([ffMiles,percentTats,iceCream])</span><br><span class="line">    classifierResult=classify0((inArr-minVals)/ranges,normMat,datingLabels,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You will probably like this person:&quot;</span>, resultList[classifierResult-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们输入对应的数据，代码帮我们输出他适不适合海伦（错过了真命天子就嘿嘿了）</p><h2 id="我们还可以通过k近邻算法，做一个手写识别系统"><a href="#我们还可以通过k近邻算法，做一个手写识别系统" class="headerlink" title="我们还可以通过k近邻算法，做一个手写识别系统"></a>我们还可以通过k近邻算法，做一个手写识别系统</h2><p>注图像已经经过处理为黑白图像（由0，1）字符组成。</p><p>00000000000011110000000000000000<br>00000000000111111000000000000000<br>00000000001111111100000000000000<br>00000000000111111111100000000000<br>00000000001111111111110000000000<br>00000000001111111111111000000000<br>00000000011111101111111000000000<br>00000000011111000111111000000000<br>00000000011111000011111100000000<br>00000000111110000001111110000000<br>00000001111100000001111110000000<br>00000001111100000000011110000000<br>00000001111100000000011111000000<br>00000001111100000000011111000000<br>00000001111100000000011111000000<br>00000001111100000000011111000000<br>00000011111100000000011111000000<br>00000001111100000000001111000000<br>00000001111110000000001111000000<br>00000001111100000000001111000000<br>00000001111100000000011111000000<br>00000001111100000000011111000000<br>00000001111110000000011111000000<br>00000001111110000001111110000000<br>00000000111110000001111110000000<br>00000000111111000011111100000000<br>00000000011111000011111000000000<br>00000000011111111111111000000000<br>00000000011111111111111000000000<br>00000000001111111111100000000000<br>00000000000011111111110000000000<br>00000000000000111110000000000000</p><p>将数据转化为测试向量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">img2Vector</span>(<span class="params">filename</span>):</span><br><span class="line">returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">fr = <span class="built_in">open</span>(filenaem)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">lineStr = fr.readline()</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = <span class="built_in">int</span>[lineStr[j]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnVect</span><br></pre></td></tr></table></figure><p>我们将这些数据输入到分类器，检<br>测分类器的执行效果。程序清单2-6所示的自包含函数handwritingClassTest()是测试分类器的代码，将其写入kNN.py文件中。在写入这些代码之前，我们必须确保将from os import listdir写入文件的起始部分，这段代码的主要功能是从os模块中导入函数listdir，它可以列出给定目录的文件名。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handwritingClassTest</span>():</span><br><span class="line">hwLabels=[]</span><br><span class="line">    trainingFileList=os.listdir(<span class="string">&#x27;trainingDigits&#x27;</span>)<span class="comment">#修改 import os 这里加上os.</span></span><br><span class="line">    m=<span class="built_in">len</span>(trainingFileList)</span><br><span class="line">    trainingMat=zeros((m,<span class="number">1024</span>)) <span class="comment">#定义文件数x每个向量的训练集</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        fileNameStr=trainingFileList[i]</span><br><span class="line">        fileStr=fileNameStr.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]<span class="comment">#解析文件</span></span><br><span class="line">        classNumStr=<span class="built_in">int</span>(fileStr.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])<span class="comment">#解析文件名</span></span><br><span class="line">        hwLabels.append(classNumStr)<span class="comment">#存储类别</span></span><br><span class="line">        trainingMat[i,:]=img2vector(<span class="string">&#x27;trainingDigits/%s&#x27;</span>%fileNameStr) <span class="comment">#访问第i个文件内的数据</span></span><br><span class="line">    <span class="comment">#测试数据集</span></span><br><span class="line">    testFileList=os.listdir(<span class="string">&#x27;testDigits&#x27;</span>)</span><br><span class="line">    errorCount=<span class="number">0.0</span></span><br><span class="line">    mTest=<span class="built_in">len</span>(testFileList)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mTest):</span><br><span class="line">        fileNameStr=testFileList[i]</span><br><span class="line">        fileStr=fileNameStr.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        classNumStr=<span class="built_in">int</span>(fileStr.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])<span class="comment">#从文件名中分离出数字作为基准</span></span><br><span class="line">        vectorUnderTest=img2vector(<span class="string">&#x27;testDigits/%s&#x27;</span>%fileNameStr)<span class="comment">#访问第i个文件内的测试数据，不存储类 直接测试</span></span><br><span class="line">        classifierResult=classify0(vectorUnderTest,trainingMat,hwLabels,<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;the classifier came back with: %d,the real answer is: %d&quot;</span> %(classifierResult,classNumStr))</span><br><span class="line">        <span class="keyword">if</span>(classifierResult!=classNumStr):</span><br><span class="line">            errorCount+=<span class="number">1.0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nthe total number of errors is: %d&quot;</span> % errorCount)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nthe total rate is:%f&quot;</span>% (errorCount/<span class="built_in">float</span>(mTest)))</span><br></pre></td></tr></table></figure><p>两个函数就完成了这个识别系统，代码和数据集在github上都有，这里不在贴。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests 库 and 正则表达式</title>
      <link href="/2018/09/21/class1/"/>
      <url>/2018/09/21/class1/</url>
      
        <content type="html"><![CDATA[<p>本文简单的讲一下requests库的基本操作</p><h2 id="requests库的安装"><a href="#requests库的安装" class="headerlink" title="requests库的安装"></a>requests库的安装</h2><p>首先确定你已经安装了requests库，如果没有的话</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>请求可以这样写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)  <span class="comment">#对应GET</span></span><br><span class="line">data = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">&quot;http://www.baidu.com&quot;</span>,data=data)  <span class="comment">#对应POST 提交表单, data为表单数据，以字典型数据存储</span></span><br><span class="line"> <span class="comment">#主要前两种后面几乎用不到</span></span><br><span class="line">r = requests.put(<span class="string">&quot;http://www.baidu.com&quot;</span>)  <span class="comment">#对应PUT</span></span><br><span class="line">r = requests.delete(<span class="string">&quot;http://www.baidu.com&quot;</span>) <span class="comment">#对应删除DELETE</span></span><br><span class="line">r = requests.head(<span class="string">&quot;http://www.baidu.com&quot;</span>)   <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>很方便的看出请求很简单，一行代码就可以完成请求，但是这只是一般网站的主页，我们肯定是要去其他部分提取信息的，所以会附加一大串的参数，比如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get?name=germey&amp;age=22&#x27;</span>)  </span><br></pre></td></tr></table></figure><h3 id="构造一些参数"><a href="#构造一些参数" class="headerlink" title="构造一些参数"></a>构造一些参数</h3><p>虽然也能完成任务，但翻页操作什么的每次都构造这个显然是不够好用，这个库当然不会让我们用这么笨的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> age <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">params = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span> : <span class="string">&quot;germey&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span> : age</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params = params)</span><br><span class="line"></span><br><span class="line">成功完成附加参数的提交</span><br><span class="line">我们还可能遇到一个最low的反爬措施（知乎） 通过User-Agent 浏览器标识来反爬虫，这个我们可以构造headers轻易的破解，还有一些需要登陆才能操作的网站同样也可以通过构造headers</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span> : <span class="string">&#x27;ABTEST=0|1534834504|v1; SNUID=1C3DF36DB3B6C05E33DD8DD8B303CE03; IPLOC=CN3201; SUID=AF8E41DF3E18960A000000005B7BB748; SUID=AF8E41DF2C18960A000000005B7BB748; SUV=00151DF1DF418EAF5B7BB74C32B4D814; weixinIndexVisited=1; ppinf=5|1534908615|1536118215|dHJ1c3Q6MToxfGNsaWVudGlkOjQ6MjAxN3x1bmlxbmFtZTo2OlBzeWNob3xjcnQ6MTA6MTUzNDkwODYxNXxyZWZuaWNrOjY6UHN5Y2hvfHVzZXJpZDo0NDpvOXQybHVJV0FROGwzSTFjYlg3M3Z1akxfd3prQHdlaXhpbi5zb2h1LmNvbXw; pprdig=xm9mkmMYDlvMRbH0pAjDEpcsEDCvoz3ORcB-9-lzvVhkxyM55AmN7NQJ8KU3Ei67B6DAqmo_DjyIu3NchvKgznUCthv3eMG2u_T1MhiMkJD7nV3HrDRKv0KVeNyQnt4Zl6D4y1v8SlHfHd-6aGhSCKW_NDIv_JqJmP-7eWQgsKw; sgid=22-36710215-AVt82MciatqU4SaMibG2iceyUs; sct=3; ppmdig=1534925103000000f514b9c5b91510b7cd851626696ec141; JSESSIONID=aaaGoZeH3bNXx-s9OFBvw; SL_GWPT_Show_Hide_tmp=1; SL_wptGlobTipTmp=1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span> : <span class="string">&#x27;weixin.sogou.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span> : <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">&#x27;http://weixin.sogou.com&#x27;</span>,headers = headers)</span><br><span class="line">当然也可以cookies = &#123;</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">&#x27;http://weixin.sogou.com&#x27;</span>,cookies = cookies)</span><br><span class="line">但显然直接复制更方便</span><br><span class="line">如果遇到反爬措施怎么更换代理呢，requests也有十分简单的方法，类似于上面的参数提交</span><br><span class="line">proxies = &#123;</span><br><span class="line"><span class="string">&quot;http&quot;</span> : <span class="string">&quot;http:127.0.0.1:8080&quot;</span>,</span><br><span class="line"><span class="string">&quot;https&quot;</span> : <span class="string">&quot;https://127.0.0.0:5555&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&#x27;http:www.zhihu.com&#x27;</span>,proxies=proxies) <span class="comment">#当然上面的代理是不能用的，你可以找国内哪些免费网站上寻找，或者自己维护一个代理池（从各大网站上爬取代理ip,验证其可用性保存在数据库备用），当然付费代理最为好用。</span></span><br><span class="line">还有一个超时操作的处理直接在末尾的timeout 参数赋值即可，如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理：</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://github.com&#x27;</span>, allow_redirects=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="常遇到的问题"><a href="#常遇到的问题" class="headerlink" title="常遇到的问题"></a>常遇到的问题</h3><p>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。</p><p>如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status() 会抛出一个 HTTPError 异常。</p><p>若请求超时，则抛出一个 Timeout 异常。</p><p>若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。</p><p>所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。<br>我们通过上面的设置，利用try except 函数可以容易的捕获这些错误<br>此外还有一些证书认证操作，比如12306,他们的证书没有被官方认证，所以爬取会报错，这个设置也很简单。把 verify 参数设置为False 即可，不过会提醒我们一个警告，我们可以选择忽略他，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings() </span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.12306.cn&#x27;</span>,verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>讲完了请求那么我们获取的数据怎么拿到呢。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.status_code  <span class="comment">#获取响应码，判断自己是否成功访问网站</span></span><br><span class="line">r.text <span class="comment">#将源码转换为text格式</span></span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 改变网页源码的编码格式，一般是gbk,或者utf-8</span></span><br><span class="line">r.url <span class="comment">#获取请求的网址</span></span><br><span class="line"><span class="built_in">type</span>(**) <span class="comment">#输出内容的格式，比如text,json ,dict</span></span><br><span class="line">r.json() <span class="comment">#可以发现，调用json(）方法，就可以将返回结果是 JSON 格式的字符串转化为字典dict</span></span><br><span class="line">r.content  <span class="comment">#图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式， 我们才可以看到这些形形色色的多媒体 所以，想要抓取它们，就要拿到它们的二进制码</span></span><br></pre></td></tr></table></figure><h2 id="正则re"><a href="#正则re" class="headerlink" title="正则re"></a>正则re</h2><p>正则表达式是处理字符串的强大工具，它有向己特定的语法结构，有了它，实现字符串的检索、替换、匹配验证都不在话下当然,对于爬虫来说，有了它，从HTML 里提取想要的信息就非常方便了<br>可以在开源中国里练手，强大的在线匹配功能<a href="http://tool.oschina.net/regex/">http://tool.oschina.net/regex/</a><br>正则不是python独有的，其他编程语言中也有，re库是整个正则表达式的实现，很方便实用。</p><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>这个函数可以检测你的正则表达式是否能成功匹配数据，如果失败就返回None,代表匹配失败。举个栗子！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)  <span class="comment">#对应正则表达式，字符串，标识符</span></span><br><span class="line">栗子：</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello 123 456 World is a demo&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello\s\d\d\d\s\d&#123;3&#125;\s\w&#123;5&#125;&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br></pre></td></tr></table></figure><p>我们的正则表达式以^作为开头，然后\s匹配空白字符，\d匹配数字,\d{3}代表匹配三个数字，\w{5},匹配字母数字或下划线共五个。我们运行一下发现匹配到了 Hello 123 456 World，调用group()获取匹配内容，span()获取匹配范围。match()函数有两个参数，1为正则，二为待匹配字符串。<br>如果我们想要得到某一具体内容怎么办呢，比如只想得到123。那么我们可以在正则表达式中用()把它括起来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.match(<span class="string">&#x27;^Hello\s(\d+)\s\d&#123;3&#125;\s\w&#123;5&#125;&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这样难免有点繁琐，我们使用通用匹配就很方便——.<em>(.可匹配除换行符之外的任意字符。</em>匹配无限次)完成上面的匹配，我们可以这样写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.match(<span class="string">&#x27;^Hello.*demo&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br></pre></td></tr></table></figure><p>那么这样真的没有缺点吗，答案是否定的：比如你想得到123这个数字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.match(<span class="string">&#x27;^Hello.*(\d+).*demo&#x27;</span>，<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>))</span><br><span class="line">运行一下发现结果不如人意并不是我们想要的</span><br></pre></td></tr></table></figure><p>这里就涉及到贪婪和非贪婪的问题，.<em>会匹配尽可能多的字符（贪婪匹配），我们只需要简单的更改就能成功(加？)<br>.</em>? 是非贪婪匹配，匹配尽可能少的字符，到数字的前面时就默认停止匹配，从而让我们得到正确的结果<br>但这里需要注意，如果匹配的结果在字符串结尾，.*?就有可能匹配不到任何内容了，因为它<br>匹配尽可能少的字符 例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;http://weibo.com/comment/KEraCN&#x27;</span></span><br><span class="line">result1 = re.match(<span class="string">&#x27;http.*?comment/(.*?)&#x27;</span>,content)</span><br><span class="line">result2 = re.match(<span class="string">&#x27;http.*?comment/(.*)&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result1&quot;</span>,result1.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;result2&#x27;</span>, result2.group(<span class="number">1</span>)) </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">result1</span><br><span class="line">result2 KEraCN</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式 修饰符被指定为一个可选的标志。<br>我们改一下字符串 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello 123 456 \nWorld is a demo&quot;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello.*demo&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line">发现报错，未成功得到字符</span><br><span class="line">这是因为．匹配的是除换行符之外的任意字符，当遇到换行符时，.*?就不能匹配了，所以导致匹配失败这里只需加一个修饰符 re.S ，即可修正这个错误：</span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello.*demo&#x27;</span>,<span class="built_in">str</span>,re.S)</span><br><span class="line">re.I  <span class="comment">#使匹配大小写不敏感</span></span><br><span class="line">re.S  <span class="comment">#使.匹配包括换行符在内的所有字符</span></span><br><span class="line">还有其他不常用，自己去查阅吧</span><br></pre></td></tr></table></figure><p>那么如果我们要匹配的字符包含.或者其他的特殊字符怎么办呢，比如匹配网址<a href="http://www.baidu.com./">http://www.baidu.com。</a> 这个时候就要用到强大的转义字符了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;www\.baidu\.com&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>match()方法是从字符串的开头匹配，我们用它来提取信息显然不方便，更适合用来检测某个字符串是否符合规则，所以我们介绍search()-扫描整个字符串返回第一个成功匹配的结果，没找到则返回None.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(pattern, string, flags=<span class="number">0</span>) <span class="comment">#对应正则表达式，字符串，标识符</span></span><br><span class="line">栗子：</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;&lt;div id = &#x27;song-list&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;h2 class = &#x27;title&#x27;&gt;经典老歌&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;p class =&#x27;introduction&#x27;&gt;</span></span><br><span class="line"><span class="string">经典老歌列表&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;ul id =&#x27;list&#x27; class = &#x27;list-gruop&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view =&#x27;2&#x27;&gt;一路有你&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view=&#x27;7&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;a href=&#x27;/2.mp3&#x27; singer=&#x27;任贤齐&#x27;&gt;沧海一声笑&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view = &#x27;4&#x27; class =&#x27;active&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;a href=&#x27;/3.mp3&#x27; singer=&#x27;齐秦&#x27;&gt;往事随风&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view=&#x27;6&#x27;&gt;&lt;a href=&#x27;/4.mp3&#x27; singer = &#x27;beyond&#x27;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view=&#x27;5&#x27;&gt;&lt;a href=&#x27;/5.mp3&#x27; singer = &#x27;陈慧琳&#x27;&gt;记事本&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li data-view=&#x27;5&#x27;</span></span><br><span class="line"><span class="string">&lt;a href =&#x27;/6.mp3&#x27; singer=&#x27;邓丽君&#x27;&gt;但愿人长久&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line">result = re.search(<span class="string">&quot;&lt;li.*?active.*?singer=&#x27;(.*?)&#x27;&gt;(.*?)&lt;/a&gt;&quot;</span>,html,re.S)</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>),result.group(<span class="number">2</span>))</span><br><span class="line">&gt;&gt;&gt;齐秦 往事随风</span><br><span class="line">result = re.search(<span class="string">&quot;&lt;li.*?singer=&#x27;(.*?)&#x27;&gt;(.*?)&lt;/a&gt;&quot;</span>,html,re.S)</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>),result.group(<span class="number">2</span>))</span><br><span class="line">&gt;&gt;&gt;任贤齐沧海一声笑</span><br></pre></td></tr></table></figure><h3 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h3><p>search方法只能返回一个值，显然不足以满足我们的需求，findall方法返回所有符合要求的字符串，以列表的形式存储。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">html 同上</span><br><span class="line">results = re.findall(<span class="string">&#x27;&lt;li.*?href=&#x27;</span>(.*?)<span class="string">&#x27;.*?singer=&#x27;</span>(.*?)<span class="string">&#x27;&gt;(.*?)&lt;/a&gt;&#x27;</span>,html,re.S)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>],result[<span class="number">1</span>],result[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;自己运行吧</span><br></pre></td></tr></table></figure><h3 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h3><p>除了提取信息我们还可用用正则修改文本，这时候就用到了sub()方法。还以上面的为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;html = re.sub(<span class="string">&#x27;&lt;a.*?&gt;|&lt;/a&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,html)</span><br><span class="line">results = re.findall(<span class="string">&#x27;&lt;li.*?&gt;(.*?)&lt;/li&gt;&#x27;</span>,html,re.S)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line"><span class="built_in">print</span>(result.strip())</span><br><span class="line">&gt;&gt;&gt;自己运行吧</span><br></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h3><p>前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 compile()方法，这个方法可以将<br>正则字符串编译成正则表达式对象，以便在后面的匹配中复用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">content = <span class="string">&#x27;2018-2-11 12:00&#x27;</span></span><br><span class="line">patten = re.<span class="built_in">compile</span>(<span class="string">&#x27;\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span>)</span><br><span class="line">pattem.split(content)</span><br></pre></td></tr></table></figure><p>另外， compile()还可以传入修饰符，例如 re.S等修饰符，这样search(),findall()等方法中<br>就不需要额外传了 所以compile()方法可以说是给正则表达式做了一层封装，以使我们更好地复用</p><p>ok 扯淡完毕本节结束具体看实例吧</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反爬微信搜狗文章</title>
      <link href="/2018/09/01/weixin/"/>
      <url>/2018/09/01/weixin/</url>
      
        <content type="html"><![CDATA[<p>本文涉及到反爬虫措施和代理池</p><h2 id="需要用的知识"><a href="#需要用的知识" class="headerlink" title="需要用的知识"></a>需要用的知识</h2><p>代理池，Pyquery解析库，requests请求库,and 万年不变的MongoDB数据库.</p><p>完成这个爬虫我们需要做下列准备，首先当然是分析一下网页的结构，我们可以随便搜索一下，发现如果不登录可以看前十页内容，登陆后可以看到100页，而且每页出现一堆文章列表，打开开发者模式发现他们都各自包含一个超链接，指向微信文章。原来搜狗已经用自己的爬虫爬取了一次文章，然后打包为自己的搜索内容，然而我们多次刷新后会出现验证界面，也就是搜狗的反爬虫机制，这也是我们开头说要用代理的原因，原理基本就是这样，然后贴代码。</p><h3 id="模拟登陆"><a href="#模拟登陆" class="headerlink" title="模拟登陆"></a>模拟登陆</h3><p>首先是设置heads,也就是模拟登陆，网站采取cookies来验证是否登陆，因此我们只需把这些复制过去，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span> : <span class="string">&#x27;ABTEST=0|1534834504|v1; SNUID=1C3DF36DB3B6C05E33DD8DD8B303CE03; IPLOC=CN3201; SUID=AF8E41DF3E18960A000000005B7BB748; SUID=AF8E41DF2C18960A000000005B7BB748; SUV=00151DF1DF418EAF5B7BB74C32B4D814; weixinIndexVisited=1; ppinf=5|1534908615|1536118215|dHJ1c3Q6MToxfGNsaWVudGlkOjQ6MjAxN3x1bmlxbmFtZTo2OlBzeWNob3xjcnQ6MTA6MTUzNDkwODYxNXxyZWZuaWNrOjY6UHN5Y2hvfHVzZXJpZDo0NDpvOXQybHVJV0FROGwzSTFjYlg3M3Z1akxfd3prQHdlaXhpbi5zb2h1LmNvbXw; pprdig=xm9mkmMYDlvMRbH0pAjDEpcsEDCvoz3ORcB-9-lzvVhkxyM55AmN7NQJ8KU3Ei67B6DAqmo_DjyIu3NchvKgznUCthv3eMG2u_T1MhiMkJD7nV3HrDRKv0KVeNyQnt4Zl6D4y1v8SlHfHd-6aGhSCKW_NDIv_JqJmP-7eWQgsKw; sgid=22-36710215-AVt82MciatqU4SaMibG2iceyUs; sct=3; ppmdig=1534925103000000f514b9c5b91510b7cd851626696ec141; JSESSIONID=aaaGoZeH3bNXx-s9OFBvw; SL_GWPT_Show_Hide_tmp=1; SL_wptGlobTipTmp=1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span> : <span class="string">&#x27;weixin.sogou.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span> : <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求网页"><a href="#请求网页" class="headerlink" title="请求网页"></a>请求网页</h3><p>当然cookies会过期复制这个是没用的。然后就是请求网页。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">global</span> PROXY</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> PROXY:</span><br><span class="line">            proxies = &#123;</span><br><span class="line">                <span class="string">&#x27;http&#x27;</span> : <span class="string">&#x27;http://&#x27;</span> + PROXY</span><br><span class="line">            &#125;</span><br><span class="line">            response = requests.get(url = url, allow_redirects = <span class="literal">False</span>, headers = headers , proxies = proxies, timeout = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = requests.get(url = url, allow_redirects = <span class="literal">False</span>, headers = headers, timeout = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">302</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;302&quot;</span>)</span><br><span class="line">            proxy = get_proxy()</span><br><span class="line">            <span class="keyword">if</span> proxy:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Using Proxy&#x27;</span>, proxy)</span><br><span class="line">                <span class="keyword">return</span> get_html(url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Get Proxy Failed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error Occurred&quot;</span>, e.args)</span><br><span class="line">        proxy = get_proxy()</span><br><span class="line">        <span class="keyword">return</span> get_html(url,count)</span><br><span class="line">    <span class="keyword">except</span> Timeout <span class="keyword">as</span> T:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error Occurred&quot;</span>, T.args)</span><br><span class="line">        proxy = get_proxy()</span><br><span class="line">        <span class="keyword">return</span> get_html(url, count)</span><br></pre></td></tr></table></figure><h3 id="反爬虫措施触发"><a href="#反爬虫措施触发" class="headerlink" title="反爬虫措施触发"></a>反爬虫措施触发</h3><p>这里我们获取搜狗的搜索结果页面，如果正常的话返回网页源码，如果触发反爬虫机制，那么我们就选择更换代理，当然我们可以加一个最大重复次数的验证，避免死循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_index</span>(<span class="params">html</span>):</span><br><span class="line">    doc = pq(html)</span><br><span class="line">    items = doc(<span class="string">&#x27;.news-box .news-list li .txt-box h3 a&#x27;</span>).items()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> item.attr(<span class="string">&#x27;href&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们解析这个网页，然后提取出对应的href，超链接然后通过生成器yield将结果返回上层，再之后就是普通的挨个访问，然后提取信息，这里不在赘述。<br>有一个问题就是pyquery好像不能把时间那个标签完整的提取出来，大佬们可以采取正则表达式尝试一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.etree <span class="keyword">import</span> XMLSyntaxError</span><br></pre></td></tr></table></figure><p>在解析过程中，我们发现程序报错显示XMLSyntaxError，这是一个不常见的解析错误，我们将其引入即可，数据库操作还是老样子也不在多提，代理池的事情下篇文章再讲~~~~</p><p>更新一下，搜狗的微信接口貌似加了点料，不能直接复制我们的请求头的全部内容到headers里 不然会永久302 无休止的更换代理也不能得到正确结果，经过测试只复制cookies就可以完成我们的任务。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装Gogs的一些坑和心得</title>
      <link href="/2018/08/30/hello-world/"/>
      <url>/2018/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>本文是自己准备搭建自己的git仓库时遇到的一些事</p><h2 id="为什么选择Gogs"><a href="#为什么选择Gogs" class="headerlink" title="为什么选择Gogs"></a>为什么选择Gogs</h2><p>Gogs作为用go语言写的轻量级的git仓库很适合大家部署在自己的服务器上，建立私人仓库更是很舒服（觉得自己代码不够漂亮）废话不多说进入正题。</p><h3 id="需要的基本内容"><a href="#需要的基本内容" class="headerlink" title="需要的基本内容"></a>需要的基本内容</h3><p>首先我们要安装数据库：所有的版本都支持 MySQL、PostgreSQL、MSSQL 和 TiDB（使用 MySQL 协议）作为数据库，并且均使用构建标签（build tags）cert 进行构建。需要注意的是，不同的版本的支持状态有所不同，请根据实际的 Gogs 提示进行操作。。我选择的是mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">代码很简单——sudo apt-get install mysql-server</span><br><span class="line"></span><br><span class="line">根据提示一步步安装，完成后可以终端输入 mysql --version  成功的话会看到mysql的版本号</span><br><span class="line"></span><br><span class="line">第二步安装git--sudo apt-get install git </span><br><span class="line"></span><br><span class="line">同样根据提示进行安装或者 sudo apt-get -y install git （默认所有需要输入操作输入<span class="built_in">yes</span>）</span><br><span class="line"></span><br><span class="line">git --version查看版本号观察是否安装成功</span><br><span class="line"></span><br><span class="line">上面都成功之后开始创建一个新用户git （是系统用户和git软件并无联系）我们将gogs安装在git用户中</span><br><span class="line"></span><br><span class="line">sudo adduser git  按照提示设置密码等</span><br><span class="line"></span><br><span class="line">切换git用户  sudo su - git</span><br><span class="line"></span><br><span class="line">先安装go语言，linux可直接用sudo apt-get install golang (直接打go是没有的会显示找不到软件包，go又名golang,镜像源中go的包为golang)   </span><br><span class="line"></span><br><span class="line">附注：如出现找不到软件包可以尝试更新镜像源，国内较好的镜像源有阿里云等，我们可以通过</span><br><span class="line"></span><br><span class="line">software-properties-gtk 然后选择合适的镜像源也可以通过编辑源文件——vim /etc/apt/sources.list 亦可以sudo gedit /etc/apt/source.list 然后把自己网上找的镜像源代码复制进去 比如这个网站里的一个源http://blog.sina.com.cn/s/blog_6bc5571a0101077t.html</span><br><span class="line">还可以通过wget 命令直接从网上下载压缩包例如 </span><br><span class="line">su - git</span><br><span class="line"></span><br><span class="line">wget https://dl.google.com/go/go1.9.2.linux-amd64.tar.gz</span><br><span class="line">网址可以自己在网页上寻找最新版的压缩包</span><br><span class="line"></span><br><span class="line">解压并删除该安装包（建议先不删避免出现错误之后重新下载）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tar -xf go1.9.2.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -f go1.9.2.linux-amd64.tar.gz</span><br><span class="line">tar.gz为二进制压缩文件解压后相当于安装在了该计算机上</span><br><span class="line"></span><br><span class="line">我们需要设置环境变量设置 GOROOT 和 GOPATH 目录到系统环境，这样，我们就可以在 git 用户下执行 go 命令。</span><br><span class="line"></span><br><span class="line">执行下方的命令</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export GOROOT=$HOME/local/go&#x27;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export GOPATH=$HOME/go&#x27;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:$GOROOT/bin:$GOPATH/bin&#x27;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line">然后运行<span class="built_in">source</span> ~/.bashrc 重载Bash 一定确保自己不会写错！认真认真认真！！！！！重要的事情说三遍</span><br></pre></td></tr></table></figure><p>大体上完成了我们可以进入正题了！！！！</p><h3 id="开始安装gogs"><a href="#开始安装gogs" class="headerlink" title="开始安装gogs"></a>开始安装gogs</h3><p>使用git安装gogs—–即使用git用户用go命令下载Gogs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ su - git</span><br><span class="line">$ go get -u github.com/gogits/gogs</span><br></pre></td></tr></table></figure><p>此命令将在 GOPATH&#x2F;src 目录下载 Gogs 的所有源代码。</p><p>个人觉得这个非常慢，刚开始弄甚至以为电脑坏了。。</p><p>切换至 $GOPATH&#x2F;src&#x2F;github.com&#x2F;gogits&#x2F;gogs 目录，并且使用下列命令搭建 Gogs。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/gogits/gogs</span><br><span class="line"></span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>官网上还可以构造分支什么的可以尝试一下。。。不做论述</p><p>既然这个比较慢那么当然有快捷办法——参考安装go的方法我们可以运行wget</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://dl.gogs.io/0.11.19/linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>等待下载完成tar zxvf 压缩包名即可将二进制的文件安装进行下列操作</p><p>两种方法完成后都可以进入gogs文件夹运行  .&#x2F;gogs web</p><p>看到这里恭喜你，基本完成了。我们可以crtl c让进程停下。。因为我们的数据库还没有配置</p><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>mysql -u root(这是用户名） -p  （因为我们要创建用户所以要用最高权限的用户）</p><p>输入密码进入然后然后数据库的基本操作百度吧。。（数据库名和数据库用户名不是一个概念）</p><p>exit;  退出数据库</p><p>再次进入gogs文件夹  .&#x2F;gogs web</p><p>浏览器输入对应网址。。。。。不知道本机ip?那么 ipconfig -a 即可看到自己的ip</p><p>我的是：<a href="http://192.168.176.129:3000/">http://192.168.176.129:3000/</a><br>然后设置对应的配置，如果还想要其他的操作那么去这里<a href="https://linux.cn/article-9391-1.html">https://linux.cn/article-9391-1.html</a></p><p>以及一些解压文件<a href="https://blog.csdn.net/zhongnanjun_3/article/details/6312678">https://blog.csdn.net/zhongnanjun_3/article/details/6312678</a></p><p>还有vim编译器的读写操作<a href="https://my.oschina.net/liujinofhome/blog/36648">https://my.oschina.net/liujinofhome/blog/36648</a></p><p>同时因为电脑的不同的不同可能还会有其他各种奇葩错误，且行且珍惜</p>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> gogs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>饿了么爬虫尝试</title>
      <link href="/2018/08/29/elm/"/>
      <url>/2018/08/29/elm/</url>
      
        <content type="html"><![CDATA[<p>本文是自己临时起意想写的一点东西。</p><h2 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a>需要用到的知识</h2><p>突发奇想，想爬取外卖商家的信息（虽然吃了一暑假外卖，要吐的感觉）。用到了分析Ajax请求，储存库依旧是MongoDB，还用了一下代理池（因为第一次爬取出现了429状态码，限制爬取速度，但是配置完代理池之后这个错误竟然消失了）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;cookie&quot;</span>: <span class="string">&quot;ubt_ssid=rp2q5djs0u6ewmuztcx8mgd2mrkv0vgy_2018-08-29; _utrace=04d8824d7caede2317d2342af2517ebf_2018-08-29; SL_GWPT_Show_Hide_tmp=1; SL_wptGlobTipTmp=1; track_id=1535537453|22aa0399855feb682fdaec9615fcab851e46acb633c7ede4a1|28e66234a33c368946d7476ac4a530f8; USERID=457663306; SID=8qvMlmIw0lzs0oBSvJXJoHiG0ohT7yC77chA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;referer&quot;</span>: <span class="string">&quot;https://www.ele.me/place/wtswdqsgbhhq?latitude=32.11645&amp;longitude=118.933531&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;x-shard&quot;</span>: <span class="string">&quot;loc=118.933531,32.1164&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><p>因为需要登陆后才能看到商家信息，所以我们在heads中加入cookies，User-agent参数则是屏蔽爬虫的标识让网站认为我们是正常的浏览。<br>通过观察我们发现网站采取Ajax,和微信与头条一样，下拉能看到更多的内容，因此我们直接爬去这部分字符串即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_URL = <span class="string">&#x27;https://www.ele.me/restapi/shopping/restaurants?&#x27;</span></span><br><span class="line">params = &#123;</span><br><span class="line">        <span class="string">&quot;extras[]&quot;</span>: <span class="string">&quot;activities&quot;</span>,</span><br><span class="line">        <span class="string">&quot;geohash&quot;</span>: <span class="string">&quot;wtswdqsgbhhq&quot;</span>,</span><br><span class="line">        <span class="string">&quot;latitude&quot;</span>: <span class="number">32.11645</span>,</span><br><span class="line">        <span class="string">&quot;limit&quot;</span>: <span class="number">24</span>,</span><br><span class="line">        <span class="string">&quot;longitude&quot;</span>: <span class="number">118.933531</span>,</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>: offset,</span><br><span class="line">        <span class="string">&quot;terminal&quot;</span>: <span class="string">&quot;web&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">url = BASE_URL + urlencode(params)</span><br></pre></td></tr></table></figure><h3 id="构造url"><a href="#构造url" class="headerlink" title="构造url"></a>构造url</h3><p>通过urlencode将文本拼接为正常的url 参数我们可以直接打印出来然后访问这个url 发现返回的是一堆字符串，当然我们要的信息就在里面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.get(url=url, headers=headers,timeout = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line"><span class="keyword">return</span> response.json()</span><br></pre></td></tr></table></figure><p>timeout 为超时处理，如果超过指定时间未响应则报错<br>得到字符串列表之后通过查找则可以找到相关的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> json:</span><br><span class="line">    <span class="keyword">yield</span> &#123;</span><br><span class="line">        <span class="string">&quot;shopname&quot;</span> : item.get(<span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;adress&quot;</span> : item.get(<span class="string">&#x27;address&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;opening_hours&quot;</span> : item.get(<span class="string">&#x27;opening_hours&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;flavors&quot;</span> : item.get(<span class="string">&#x27;flavors&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;piecewise_agent_fee&quot;</span> : item.get(<span class="string">&#x27;piecewise_agent_fee&#x27;</span>).get(<span class="string">&#x27;description&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;order_lead_time&quot;</span> : item.get(<span class="string">&#x27;order_lead_time&#x27;</span>),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代理的使用"><a href="#代理的使用" class="headerlink" title="代理的使用"></a>代理的使用</h3><p> 分别为店家名称，地址，开放时间，特色，配送费，平均配送时间。<br> 之后储存全套服务不在啰嗦。<br> 还剩下刚开始说的代理池，虽然没太大用，但为了避免时不时的429状态码，还是加上为妙。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_proxy</span>():</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       response = requests.get(PROXY_POOL_URL)</span><br><span class="line">       <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">           <span class="keyword">return</span> response.text</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">   <span class="keyword">except</span> ConnectionError:</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><br> 运用代理则为<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> PROXY:</span><br><span class="line">   proxies = &#123;</span><br><span class="line">       <span class="string">&quot;https&quot;</span> : <span class="string">&quot;https://&quot;</span> + PROXY</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Using proxy&quot;</span>,PROXY)</span><br><span class="line">   response = requests.get(url = url,headers = headers,allow_redirects = <span class="literal">False</span>,proxies = proxies,timeout = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br> proxies 就是requests包中的代理参数，allow_redirects是禁止重定向，requests函数遇到错误会自动帮我们重定向，因为我们要用代理所以禁止重定向。<br> 基本这个爬虫就完成了，说说它的缺点：这个界面没有详细的餐点目录仅有一些店家的信息，还需多多努力，且行且珍惜</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的爬虫</title>
      <link href="/2018/08/29/pyquery/"/>
      <url>/2018/08/29/pyquery/</url>
      
        <content type="html"><![CDATA[<p>本文以简单的例子讲如何写爬虫</p><p>##需要的知识<br>多进程，pyquery解析，pymongo链接数据库，requests发送请求</p><p>这里以一个简单的实例讲解一下如何提取网页信息并储存在MongoDB数据库</p><h3 id="主代码结构"><a href="#主代码结构" class="headerlink" title="主代码结构"></a>主代码结构</h3><p>爬取的网站是<a href="https://isujin.com/">https://isujin.com</a><br>主函数很简单一层一层的传递</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">page</span>):</span><br><span class="line">    urls = get_index(page)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        html = get_html(url)</span><br><span class="line">        <span class="keyword">if</span> html:</span><br><span class="line">            data = parse_html(html)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                save_as_text(html)</span><br><span class="line">                save_to_mongo(data)<span class="comment"># 如果没安装mongo可以取消此项</span></span><br><span class="line">                save_picture(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h4><p>首先是获取所有的链接</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">page</span>):</span><br><span class="line">    URL = <span class="string">&#x27;https://isujin.com/page/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(URL)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            html = response.text</span><br><span class="line">            doc = pq(html)</span><br><span class="line">            urls = doc(<span class="string">&#x27;#primary .post &gt; a&#x27;</span>).items()</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">                url = url.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">                <span class="keyword">yield</span> url</span><br><span class="line">            <span class="keyword">return</span> doc(<span class="string">&#x27;#post0 &gt; h2 &gt; a&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p> 我们提取出所有的网页的url 如果返回值的状态码为200证明为正确响应，通过pq(html)将HTML网页转化为pyquery的格式，pyquery依据CSS选择器提取信息，#开头根据标签的id属性提取；.开头则依据class属性提取 具体CSS选择器的内容可以去<a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls = doc(<span class="string">&#x27;#primary .post &gt; a&#x27;</span>).items()</span><br></pre></td></tr></table></figure><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>items() 在pyquery中是一个生成器把所有的选中的许多<a href="....">生成一个列表，然后我们用for循环进行遍历每个标签并提取出链接 通过yield迭代器将链接返回到外层</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>返回html文档的函数不在赘述，很简单。接下来是解析html文档提取我们要的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">html</span>):</span><br><span class="line">    doc = pq(html)</span><br><span class="line">    title = doc(<span class="string">&#x27;.title&#x27;</span>).text()</span><br><span class="line">    time = doc(<span class="string">&#x27;div.stuff &gt; span:nth-child(1)&#x27;</span>).text()</span><br><span class="line">    readcount = doc(<span class="string">&#x27;div.stuff &gt; span:nth-child(2)&#x27;</span>).text()</span><br><span class="line">    content = doc(<span class="string">&#x27;.content&#x27;</span>).text()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span> : title,</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span> : time,</span><br><span class="line">        <span class="string">&#x27;readcount&#x27;</span> : readcount,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span> : content</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和提取herf一样 通过CSS 选择器获取我们索要的节点然后text() 即可提取所要的文本信息。之后以字典的形式返回数据到外层函数（因为数据库存储是以字典型）</p><h3 id="mongodb储存信息"><a href="#mongodb储存信息" class="headerlink" title="mongodb储存信息"></a>mongodb储存信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = pymongo.MongoClient(MONGO_URl)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_mongo</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> db[MONGO_TABLE].update(&#123;<span class="string">&#x27;title&#x27;</span> : data[<span class="string">&#x27;title&#x27;</span>]&#125;,&#123;<span class="string">&#x27;$set&#x27;</span> : data&#125;, <span class="literal">True</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Saved to Mongo&quot;</span>, data[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Saved to Mongo Failed&quot;</span>, data[<span class="string">&#x27;title&#x27;</span>])</span><br></pre></td></tr></table></figure><p>mongodb数据库的操作也极为简单，设定好MONGO_URL &#x3D; ‘localhost’ MONGO_DB &#x3D; ‘数据库名称’ MONGO_TABLE &#x3D; ‘表名’<br>我们采取更新的方式储存，如果信息已经出现我们选择更新，以title为关键字，如果title对应的数据已经出现那么就更新它更新的内容为{‘$set’ : data}，也就是data的全部数据，若最后一个参数为false 那么如果只执行更新操作，原来不存在的数据不会插入. MONGO 学习网站可以参考这个很简单<a href="http://www.runoob.com/mongodb/mongodb-update.html">http://www.runoob.com/mongodb/mongodb-update.html</a></p><h3 id="储存照片（content"><a href="#储存照片（content" class="headerlink" title="储存照片（content)"></a>储存照片（content)</h3><p>其他储存照片也是一样的不在赘述贴一下代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_picture</span>(<span class="params">html</span>):</span><br><span class="line">    doc = pq(html)</span><br><span class="line">    images = doc(<span class="string">&#x27;#jg &gt; a&#x27;</span>).items()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(doc(<span class="string">&#x27;title&#x27;</span>)):</span><br><span class="line">        os.mkdir(doc(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        image = image.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(image)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                file_path = <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(doc(<span class="string">&#x27;.title&#x27;</span>).text(),md5(response.content).hexdigest())</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Downloading&quot;</span>,file_path)</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(response.content)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Already Downloaded&quot;</span>,file_path)</span><br><span class="line">        <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Download Error&quot;</span>, e.args)</span><br></pre></td></tr></table></figure><p>需要注意的是储存文本时f.write()中的内容必须为字符串</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>一个简易爬虫就写好了，还差最后一个多进程问题</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = Pool()</span><br><span class="line">    group = ([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">14</span>)])</span><br><span class="line">    pool.<span class="built_in">map</span>(main,group)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>pool &#x3D; Pool() 没有指定的话会根据系统自动分配，通过map()函数,map(main,group)，第一个参数是方法，第二个是数组列表，简单的来说就是把main方法依次执行<br>close() 关闭pool，使其不在接受新的任务。<br>join() 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用<br>具体请看大神的作品 <a href="https://cuiqingcai.com/3335" title="崔庆才的博客">https://cuiqingcai.com/3335</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python链接数据库报错</title>
      <link href="/2018/08/28/first/"/>
      <url>/2018/08/28/first/</url>
      
        <content type="html"><![CDATA[<p>本文是自己刚接触python时踩的坑</p><h2 id="在pycharm中连接数据库报错"><a href="#在pycharm中连接数据库报错" class="headerlink" title="在pycharm中连接数据库报错"></a>在pycharm中连接数据库报错</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$   <span class="keyword">import</span> hashlib,os,requests,ast</span><br><span class="line">$   <span class="keyword">import</span> pymysql</span><br><span class="line">$   <span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">$   <span class="comment">#数据库链接</span></span><br><span class="line">$   conn=pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,port=<span class="number">3306</span>,user=<span class="string">&quot;root&quot;</span>,passwd=<span class="string">&quot;1820401746yuan.A&quot;</span>,db=<span class="string">&quot;pm&quot;</span>)</span><br><span class="line">$   cursor=conn.cursor()   <span class="comment">#创建cursor对象</span></span><br><span class="line">$   host 主机名也可用<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>.代替（本地服务器）</span><br><span class="line"></span><br><span class="line">port端口（附查看方式，登陆mysql输入下列代码）</span><br><span class="line"></span><br><span class="line"> show <span class="keyword">global</span> variables like <span class="string">&#x27;port&#x27;</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| port          | <span class="number">3306</span>  |</span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.16</span> sec)</span><br><span class="line"></span><br><span class="line">user 用户名默认为root——权限最大的用户</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1045</span> (<span class="number">28000</span>): Access denied <span class="keyword">for</span> user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> (using password: NO)</span><br></pre></td></tr></table></figure><p>网上有很多的办法，但都不能解决我的问题。</p><p>比如赋予数据库权限，以及创建新用户等等。。。</p><p>然后在我的努力寻找下成功了</p><h3 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h3><p>更换了root密码的认证方式解决，新版mysql使用的caching_sha2_password，换成mysql_native_password我就可以连上了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">然后输入ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;password&#x27;</span>; password即你的密码）</span><br></pre></td></tr></table></figure><p>转自<br><a href="https://blog.csdn.net/dongweionly/article/details/80273095" title="原博客地址">https://blog.csdn.net/dongweionly/article/details/80273095</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
